1.假如判断语句写成if（i=3）,编译器不会报错；而写成if（3=i）会报“试图向常数赋值”的错误；
  所以，这里编写判断语句的技巧是：if（3==i）,常数在变量前面；
  
2.有符号数和无符号数的比较过程中，有符号数会转变成无符号数，容易造成程序bug
  比如：size_t strlen(char const *string);  // 返回值：无符号整型
		int array[]={ 23,34,12,17,204,99,16 };
		#define TOTAL_ELEMENTS (sizeof(array)/sizeof(array[0]))
		
        bool flag = FALSE;
		// strlen返回无符号数，在比较过程中，-1被转换为无符号（65535），判断语句不成立。
		if(strlen(“123”) > -1) 
		{
			flag = TRUE;
		}
		// TOTAL_ELEMENTS为无符号(sizeof返回无符号数)，在比较过程中，-1被转换为无符号（65535），判断语句不成立。
		if(TOTAL_ELEMENTS > -1) 
		{
			flag = TRUE;
		}		
	上例中的TOTAL_ELEMENTS定义为：
		#define TOTAL_ELEMENTS (sizeof(array)/sizeof(array[0]))
	而不是：
		#define TOTAL_ELEMENTS (sizeof(array)/sizeof(int))
	因为前者可以在不修改#define语句的情况下改变数组的基本类型（比如：int修改为char）。
	
3.malloc与new分配内存的不同点：
	malloc的函数声明：
		void *malloc(size_t size);// 备注：void* 表示未确定类型的指针，void *可以指向任何类型的
	返回值：
		如果分配成功则返回指向被分配内存的指针(此存储区中的初始值不确定)，否则返回空指针NULL。当内存不再使用时，应使用free()函数将内存块释放。
	注意：ANSIC标准规定，该函数返回为void型指针，因此必要时要进行类型转换（强制转换为当前指针类型）。
	例如：
		int *p;
		p = (int*)malloc(sizeof(int) * 128);
		//分配128个（可根据实际需要替换该数值）整型存储单元，
		//并将这128个连续的整型存储单元的首地址存储到指针变量p中
	
	NEW:malloc 和 new 至少有两个不同: new 返回指定类型的指针，并且可以自动计算所需要大小。比如：
		int *p;
		int *parr;	
		p = new int;
		//返回类型为int *类型(整数型指针)，分配大小为sizeof(int);	
		parr = new int[100];
		//返回类型为int *类型(整数型指针)，分配大小为sizeof(int) * 100;
	
	注意：
		第一、malloc 函数返回的是 void * 类型。
			对于C++，如果你写成：p = malloc (sizeof(int)); 则程序无法通过编译，报错：“不能将 void* 赋值给 int * 类型变量”。
			所以必须通过 (int *) 来将强制转换。而对于C，没有这个要求，但为了使C程序更方便的移植到C++中来，建议养成强制转换的习惯。
		第二、函数的实参为 sizeof(int) ，用于指明一个整型数据需要的大小。
			在Linux中可以有这样：malloc(0),这是因为Linux中malloc有一个下限值16Bytes，注意malloc(-1)是禁止的；但是在某些系统中是不允许malloc(0)的。
		在规范的程序中我们有必要按照这样的格式去使用malloc及free:
			1	type *p;
			2	if(NULL == (p = (type*)malloc(sizeof(type))))
			3	/*请使用if来判断,这是有必要的*/
			4	{
			5		perror("error...");
			6		exit(1);
			7	}
			8	.../*其它代码*/
			9	free(p);
			10	p = NULL;/*请加上这句*/
			
4.sizeof和strlen的区别
	char str[20]="0123456789"; 
	int   a=strlen(str); /*a=10;strlen 计算字符串的长度，以\0'为字符串结束标记。 
	int   b=sizeof(str); /*b=20;sizeof 计算的则是分配的数组str[20] 所占的内存空间的大小，不受里面存储的内容影响
    注意：strlen没有计入‘\0’字符，如果要分配空间，需定义为:malloc(strlen(str)+1)
	
5.一个'L'与两个'L'的NULL
	一个'L'的NUL用于结束ACSLL字符串。
	两个'L'的NULL用于什么也指向（空指针）。
	
6.一个switch语句允许有257个case语句（满足一个8bit字符的所有情况）

7.
63页
枚举的特点：#define定义的名字一般在编译时被丢掉，而枚举名字一直在调速器中可见，在调试代码时使用它们。
理解C语言声明的优先级规则：
	A 声明从它的名字开始读取，然后按照优先级顺序依次读取。
	B 优先级从高到低依次是：
	  B.1  声明中被括号括起来的那部分
	  B.2  后缀操作符：
	       括号（）表示这是一个函数，而方括号[]表示这是一个数组。
	  B.3  前缀操作符：星号*表示“指向...的指针”。
	C 如果const和（或）volatile关键字的后面紧跟类型说明符（如int，long等），那么它作用于类型说明符。在其他情况下，const和（或）volatile关键字作用于它左边紧邻的指针星号。
	C语言声明一例：
	char * const *（*next）（）；
	解析：next是一个指向函数的指针，该函数返回另一个指针，该指针指向一个只读的指向char的指针。
	char * （*c[10]）（int **p）；
	解析：c是一个数组【0..9】，它的元素类型是函数指针，该函数形参p一个二级int类型的指针;该函数的返回值指向一个char类型的指针。

一级指针和二级指针：
	一级指针交换变量值，二级指针交换指针地址。

68页
	typedef与#define的区别：
		1.首先，可以用其他类型说明符对宏类型名进行扩展，但对typedef所定义的类型名却不能这样：
      #define peach int
      unsigned peach i; /*没问题,unsigned 扩展为无符号*/
			
      typedef int banana;
      unsigned banana i; /*错误！非法,unsigned 扩展为无符号*/
    2.其次,在连续几个变量的声明中,用typedef定义的类型能保证声明中所有的变量均为同一种类型,而用#define定义的类型则无法保证，如下所示：
      #define int_ptr int*
      int_ptr chalk,cheese; 
	  	/*经过宏扩展，此行变为int * chalk，cheese；chalk为指向int的指针，而cheese则是一个int*/
	  	
	  	typedef char * char_ptr;
	  	char_ptr Bentley,Rolls_Royce;
	  	/*Bentley和Rolls_Royce的类型相同，都是指向char的指针*/
		3.typedef struct fruit{ int weight, price_per_lb; } fruit; 
			声明的两种方式：struct fruit mandarin; 	/* 使用结构标签“fruit” */
											fruit mandarin; 				/* 使用结构类型“fruit” */
		4.结构标签可以取一个“_tag”结尾的名字，使得辨认特定名字变得简单。
		5.strcmp函数比较两个字符串是否相等？当两个字符串相等时，返回值是0.		
      例如：if (!strcmp(s, "volatile")) return QUALIFIER;
        或者#define STRCMP(a,R,b) (strcmp(a,b) R 0)
            if (STRCMP(s, ==,"volatile")) return QUALIFIER;
79页
    理解复杂函数声明:我们可以通过cdecl.c程序，解释这个声明表示什么意思.	

第4章
80页
	区分定义和声明：
		声明:他所说明的并非自身，而是描述其他地方创建的对象。
		定义:它为对象分配内存。
		
	数组与指针不一样：
		extern对象声明告诉编译器对象的类型和名字，对象的内存分配则再别处进行。由于未在声明中为数组分配内存，所以并不需要提供数组的长度信息。
		对于多维数组，需要提供最左边一维之外其他维的长度-这就给编译器足够的信息产生相应的代码。
		
	指针变量：
		char类型指针变量：
		①C/C++语法中输出字符串指针，就是输出字符串，也就是说输出一个char*的指针一定是输出一个字符串，而不会输出指针，其它的类型都不会这样，所以你把它转成void*就会输出地址。
		例子：
		#include<iostream>
		using namespace std;
		
		int main()
		{
			void *pa;
			char a;
			char *p=&a; 
			
			pa = &a;
			cout<<(void*)p<<endl<<a<<endl;
			cout<<pa<<endl;
		}
		实例解析char类型指针与其他类型指针的地址差异分析：
			int main() 
			{ 
				char x[10]= "tanzheng";
				char *x_pter=x;
				int y[8]= { 2,4,6,8,10,12,14,16 };
				int *y_pter=y;
				
				char *str1 = "abcdefdf";
				char *str2 = "abcdefdf";
				char *str3 = "abcdefdfg";
				
				std::cout << "Value of x variable: ";
				std::cout << x << std::endl;
				
				std::cout << "Value of &x[0] variable: ";
				std::cout << &x[0] << std::endl;
	
				std::cout << "Value of (void *)x variable: ";
				std::cout << (void *)x << std::endl;
				
				std::cout << "Value of &x variable: ";
				std::cout << &x << std::endl;
				
				std::cout << "Value of (void *)x[0] variable: ";
				std::cout << (void *)&x[0] << std::endl;
				
				std::cout << "Value of x_pter variable: ";
				std::cout << x_pter << std::endl;
				
				std::cout << "Value of (void *)x_pter variable: ";
				std::cout << (void *)x_pter << std::endl;
				
				std::cout << "Value of &x_pter variable: ";
				std::cout << &x_pter << std::endl;
				
				std::cout << "Value of y variable: ";
				std::cout << y << std::endl;
				
				std::cout << "Value of &y variable: ";
				std::cout << &y << std::endl;
				
				std::cout << "Value of &y[0] variable: ";
				std::cout << &y[0] << std::endl;
				
				std::cout << "Value of y_pter variable: ";
				std::cout << y_pter << std::endl;
				
				std::cout << "Value of &y_pter variable: ";
				std::cout << &y_pter << std::endl;
				
				if ((void *)str1 == (void *)str2)
				{
					std::cout << "(void *)str1 == (void *)str2" << std::endl;
				}
				else
				{
					std::cout << "(void *)str1 != (void *)str2" << std::endl;
				}
				std::cout << "Value of (void *)str1 variable: ";
				std::cout << (void *)str1 << std::endl;
				std::cout << "Value of (void *)str2 variable: ";
				std::cout << (void *)str2 << std::endl;
				std::cout << "Value of (void *)str3 variable: ";
				std::cout << (void *)str3 << std::endl;

				return 0;
			}
			Value of x variable: 							tanzheng
			Value of &x[0] variable: 					tanzheng
			Value of (void *)x variable:			00FEFE0C
			Value of &x variable: 						00FEFE0C
			Value of (void *)&x[0] variable: 	00FEFE0C
			Value of x_pter variable: 				tanzheng
			Value of (void *)x_pter variable: 00FEFE0C
			Value of &x_pter variable: 				00FEFE00
			Value of y variable: 							00FEFDD8
			Value of &y variable: 						00FEFDD8
			Value of &y[0] variable: 					00FEFDD8
			Value of y_pter variable: 				00FEFDD8
			Value of &y_pter variable: 				00FEFDCC
			(void *)str1 == (void *)str2
			Value of (void *)str1 variable: 	00FEFDCC
			Value of (void *)str2 variable: 	00FEFDCC
			Value of (void *)str3 variable: 	00FEFDCC
			
			1.为什么char*指针类型的x取地址时,需强制转换(void *)类型？其他类型的指针变量取地址时不需要强制转换？
				1)char*类型把字符串就是放在文字常量区，定义后不能修改且默认读取字符串数据，强制转换为(void *)类型，才能读取保存在文字常量区首地址。
				2)其他类型的指针（例如short int、long int）可直接取指针变量的地址。
			2.指针变量有几种形态？
				1)y表示指针y对应的内存空间（可以说就是指针本身的值）
   			2)&y表示当前指针对应的内存空间的首地址（存放指针的地址）
   			3)*y表示指针y所指向的变量对应的整个内存空间。（指针指向的空间）
   		3.char*为什么能直接赋值字符串，常规操作时赋予指针地址？比如：char *str=“tanzheng”；
   			1)字符串保存在文字常量区，编译时就确定了，程序运行时实际就是把保存“tanzheng”这个地址，赋值给指针变量str。
   			2)把上述定义的指针变量赋值，比如：*str='A',会报错误。因为*str属于字符常量区，此内存区域只读不能写。
			4.定义连个字符串，比如：char *str1=“tanzheng”;char *str2=“tanzheng”,运行结果为：str1与str2的指针地址相等，为什么？
   			1)相同的字符串在某些编译器中有相同的地址，比较是否为同一字符串时，可以比较地址是否相同。
   				(注意：str1与str2的值不一定相同，这取决于编译器的行为。)
   		5.声明char a[];出现报错？
   			1)声明数组时，如果没有给变量初始化就必须指明数组的长，否则回报错。
   		6.字符数组与字符指针的本质区别？比如：char a[] = "abcde";与char *b = "abcde";
   			1)char 数组的初始化器会将匿名数组(文字常量的字符串)的内容复制到对象所处的空间中，而 char* 的初始化器会将匿名数组(文字常量的字符串)的首地址赋值给对象。
			
第5章
91页
	对衔接的思考
		函数库、链接和载入
			
		警惕Interpositioning
			1.Interpositioning就是通过编写与库函数同名的函数来取代该函数的行为。
			2.同名函数会让程序调用时出错。
			准则;不要让程序中的任何符号成为全局的。除非有意把他们作为程序的接口之一。（通过把函数声明为static函数，使它在所在文件之外不可见或者另外取一个函数名字）
		
		
第6章
115页
	6.1 a.out及其传说
	6.2 段(segments)
		1.一个可执行文件有三个段:文本段(代码段)、数据段、bss段(Block Started by Symbol)，可用size的命令查看段的大小。
			text指的是程序指令
			data指的是所有的经过初始化后的全局变量和静态变量
			bss段则是未经初始化的全局变量和静态变量，但是bss段不增加目标文件的大小，一般只是记录bss段的大小。
	6.4 堆栈段
		1.堆栈为函数内部的局部变量提供存储空间。
		2.进行函数调用时，堆栈存储与此有关的一些维护性信息。包括：函数调用地址、人和不适合装入寄存器的参数以及寄存器值得保存。
		3.堆栈也可以被用作暂存区。比如：计算一盒很长的算术表达式时，它可以把部分计算结果压到堆栈中，当需要时再把它从堆栈中取出。例如：alloca()函数分配内存就在堆栈中。
		
	6.8 setjmp和longjmp
		1.setjmp(jmp_buf j)必须首先被调用。表示“使用变量j记录现在的位置。函数返回0”
		2.longjmp(jmp_buf j,int i)可以接着被调用。它表示“回到j所记录的位置，让它看上去像是从原来的setjmp()函数返回一样，但是函数返回i,使代码能够知道它是通过longjmp返回的”
		3.当使用longjmp()时,j的内容被销毁。
		4.goto语句不能跳出C语言当前的函数(这也是“longjmp”取名的由来，它可以跳的很远，甚至可以跳到其他文件的函数之中)。
		5.用longjmp只能跳回到曾经到过的地方。在执行setjmp的地方留下有一个过程活动记录。
		例如：
			#include "segjmp.h"
			jmp_buf j;
			#include "segjmp.h"
			
			banana() {
				printf("in banana() \n");
				longjmp(buf,1);
				/*以下代码不会被执行*/
				printf("you'll never see this,because i longjmp");
			}
			main()
			{
				if(setjmp(buf))
					printf("back in main \n");
				else {
					printf("first time through \n");
					banana();
				}
			}
			输出结果：
				first time through
				in banana()
				back in main
		注意：像goto一样，setjmp和longjmp使得程序难以理解和调试，如果不是出于特殊需要，最好避免使用它。
	
	6.11	有用的C语言工具
		1.
		
	6.12 
	
	6.13 汇编嵌入C代码中
		可以在汇编代码前冠以关键字“__asm”，也可以只使用关键字一次，把所有的汇编代码放入花括号内;
		例如：
			__asm {
				mov ah,2;
				mov dl,43h;
				int 21h;
			}
	
第7章(对内存的思考)			
137页
	内存速度的挑战大于内存速度。
	MS-DOC 640K的限制缘何而来：
		1.这个限制源于Inter8086这个最初的DOS机器的最大地址范围。8086支持20位地址，总共时1MB的内存，
		2.F0000到FFFFF          64KB，永久性的ROM区域BIOS、诊断信息等
		  D0000到EFFFF          128KB，用于ROM存储区域
		  C0000到CFFFF          64KB，用于BIOS扩展（XT硬盘）
		  B0000到BFFFF          64KB，用于常规性的内存显示
		  A0000到AFFFF          64KB，用于内存扩展
		  其余
		  00000到9FFFF          640KB，用于应用程序
	PC的内存模型
		MicrosoftC认可下面的内存模型：
			small		所有指针都为16位，代码和数据都限定在一个单一的段中，程序最大规模为128KB(代码段和数据段各64KB)
			large		所有指针都为32位，程序可以包含许多个64KB的段
			medium	代码指针为32位，所以代码段可能有多个。数据指针为16位，所以只有一个64KB的数据段。
		  compact medium的另一种形式：代码指针为16位，所以代码最多不超过64KB.数据指针为32位，所以数据可以占据多个段，但堆栈里的数据仍限制在一个64KB的段内。
		MicrosoftC认可下面非标准的关键字：
			__near  16位指针
			__far   32位指针，但它所指的对象必须全部位于同一个段中(所有的对象均不得超过64KB)
			__huge  32位指针，上述所有的对段的限制都不存在
147页
	7.3 虚拟内存
		虚拟内存的基本思路是用廉价但缓慢的磁盘来扩充快速却昂贵的内存。
	
	









参考文献：c专家编程.pdf
