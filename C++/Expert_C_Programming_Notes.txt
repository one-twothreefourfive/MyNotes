1.假如判断语句写成if(i=3),编译器不会报错;而写成if(3=i)会报“试图向常数赋值”的错误;
  所以,这里编写判断语句的技巧是：if(3==i),常数在变量前面;
  
2.有符号数和无符号数的比较过程中,有符号数会转变成无符号数,容易造成程序bug
  比如：size_t strlen(char const *string);  // 返回值：无符号整型
		int array[]={ 23,34,12,17,204,99,16 };
		#define TOTAL_ELEMENTS (sizeof(array)/sizeof(array[0]))
		
        bool flag = FALSE;
		// strlen返回无符号数,在比较过程中,-1被转换为无符号(65535),判断语句不成立.
		if(strlen(“123”) > -1) 
		{
			flag = TRUE;
		}
		// TOTAL_ELEMENTS为无符号(sizeof返回无符号数),在比较过程中,-1被转换为无符号(65535),判断语句不成立.
		if(TOTAL_ELEMENTS > -1) 
		{
			flag = TRUE;
		}		
	上例中的TOTAL_ELEMENTS定义为：
		#define TOTAL_ELEMENTS (sizeof(array)/sizeof(array[0]))
	而不是：
		#define TOTAL_ELEMENTS (sizeof(array)/sizeof(int))
	因为前者可以在不修改#define语句的情况下改变数组的基本类型(比如：int修改为char).
	
3.malloc与new分配内存的不同点：
	malloc的函数声明：
		void *malloc(size_t size);// 备注：void* 表示未确定类型的指针,void *可以指向任何类型的
	返回值：
		如果分配成功则返回指向被分配内存的指针(此存储区中的初始值不确定),否则返回空指针NULL.当内存不再使用时,应使用free()函数将内存块释放.
	注意：ANSIC标准规定,该函数返回为void型指针,因此必要时要进行类型转换(强制转换为当前指针类型).
	例如：
		int *p;
		p = (int*)malloc(sizeof(int) * 128);
		//分配128个(可根据实际需要替换该数值)整型存储单元,
		//并将这128个连续的整型存储单元的首地址存储到指针变量p中
	
	NEW:malloc 和 new 至少有两个不同: new 返回指定类型的指针,并且可以自动计算所需要大小.比如：
		int *p;
		int *parr;	
		p = new int;
		//返回类型为int *类型(整数型指针),分配大小为sizeof(int);	
		parr = new int[100];
		//返回类型为int *类型(整数型指针),分配大小为sizeof(int) * 100;
	
	注意：
		第一、malloc 函数返回的是 void * 类型.
			对于C++,如果你写成：p = malloc (sizeof(int)); 则程序无法通过编译,报错：“不能将 void* 赋值给 int * 类型变量”.
			所以必须通过 (int *) 来将强制转换.而对于C,没有这个要求,但为了使C程序更方便的移植到C++中来,建议养成强制转换的习惯.
		第二、函数的实参为 sizeof(int) ,用于指明一个整型数据需要的大小.
			在Linux中可以有这样：malloc(0),这是因为Linux中malloc有一个下限值16Bytes,注意malloc(-1)是禁止的;但是在某些系统中是不允许malloc(0)的.
		在规范的程序中我们有必要按照这样的格式去使用malloc及free:
			1	type *p;
			2	if(NULL == (p = (type*)malloc(sizeof(type))))
			3	/*请使用if来判断,这是有必要的*/
			4	{
			5		perror("error...");
			6		exit(1);
			7	}
			8	.../*其它代码*/
			9	free(p);
			10	p = NULL;/*请加上这句*/
			
4.sizeof和strlen的区别
	1）sizeof和strlen的区别
		char str[20]="0123456789"; 
		int  a=strlen(str); /*a=10;strlen 计算字符串的长度,以\0'为字符串结束标记. */
		int  b=sizeof(str); /*b=20;sizeof 计算的则是分配的数组str[20] 所占的内存空间的大小,不受里面存储的内容影响*/
	    注意：strlen没有计入‘\0’字符,如果要分配空间,需定义为:malloc((strlen(str)+1)*sizeof(char))
    2）运用sizeof计算分配空间的样例：
		char str[]="0123456789";
		malloc(sizeof(str)*sizeof(char));			/* sizeof(str)=11;sizeof计入了‘\0’字符,而strlen(str)=10 */
       	
5.一个'L'与两个'L'的NULL
	一个'L'的NUL用于结束ACSLL字符串.
	两个'L'的NULL用于什么也指向(空指针).
	
6.一个switch语句允许有257个case语句(满足一个8bit字符的所有情况)

7.
63页
枚举的特点：#define定义的名字一般在编译时被丢掉,而枚举名字一直在调速器中可见,在调试代码时使用它们.
理解C语言声明的优先级规则：
	A 声明从它的名字开始读取,然后按照优先级顺序依次读取.
	B 优先级从高到低依次是：
	  B.1  声明中被括号括起来的那部分
	  B.2  后缀操作符：
	       括号()表示这是一个函数,而方括号[]表示这是一个数组.
	  B.3  前缀操作符：星号*表示“指向...的指针”.
	C 如果const和(或)volatile关键字的后面紧跟类型说明符(如int,long等),那么它作用于类型说明符.在其他情况下,const和(或)volatile关键字作用于它左边紧邻的指针星号.
	C语言声明一例：
	char * const *(*next)();
	解析：next是一个指向函数的指针,该函数返回另一个指针,该指针指向一个只读的指向char的指针.
	char * (*c[10])(int **p);
	解析：c是一个数组【0..9】,它的元素类型是函数指针,该函数形参p一个二级int类型的指针;该函数的返回值指向一个char类型的指针.

一级指针和二级指针：
	一级指针交换变量值,二级指针交换指针地址.

68页
	typedef与#define的区别：
		1.首先,可以用其他类型说明符对宏类型名进行扩展,但对typedef所定义的类型名却不能这样：
      #define peach int
      unsigned peach i; /*没问题,unsigned 扩展为无符号*/
			
      typedef int banana;
      unsigned banana i; /*错误!非法,unsigned 扩展为无符号*/
    2.其次,在连续几个变量的声明中,用typedef定义的类型能保证声明中所有的变量均为同一种类型,而用#define定义的类型则无法保证,如下所示：
      #define int_ptr int*
      int_ptr chalk,cheese; 
	  	/*经过宏扩展,此行变为int * chalk,cheese;chalk为指向int的指针,而cheese则是一个int*/
	  	
	  	typedef char * char_ptr;
	  	char_ptr Bentley,Rolls_Royce;
	  	/*Bentley和Rolls_Royce的类型相同,都是指向char的指针*/
		3.typedef struct fruit{ int weight, price_per_lb; } fruit; 
			声明的两种方式：struct fruit mandarin; 	/* 使用结构标签“fruit” */
							fruit mandarin; 				/* 使用结构类型“fruit” */
		4.结构标签可以取一个“_tag”结尾的名字,使得辨认特定名字变得简单.
		5.strcmp函数比较两个字符串是否相等？当两个字符串相等时,返回值是0.		
      例如：if (!strcmp(s, "volatile")) return QUALIFIER;
        或者#define STRCMP(a,R,b) (strcmp(a,b) R 0)
            if (STRCMP(s, ==,"volatile")) return QUALIFIER;
79页
    理解复杂函数声明:我们可以通过cdecl.c程序,解释这个声明表示什么意思.	

第4章
80页
	区分定义和声明：
		声明:他所说明的并非自身,而是描述其他地方创建的对象.
		定义:它为对象分配内存.
		
	数组与指针不一样：
		extern对象声明告诉编译器对象的类型和名字,对象的内存分配则再别处进行.由于未在声明中为数组分配内存,所以并不需要提供数组的长度信息.
		对于多维数组,需要提供最左边一维之外其他维的长度-这就给编译器足够的信息产生相应的代码.
		
	指针变量：
		char类型指针变量：
		①C/C++语法中输出字符串指针,就是输出字符串,也就是说输出一个char*的指针一定是输出一个字符串,而不会输出指针,其它的类型都不会这样,所以你把它转成void*就会输出地址.
		例子：
		#include<iostream>
		using namespace std;
		
		int main()
		{
			void *pa;
			char a;
			char *p=&a; 
			
			pa = &a;
			cout<<(void*)p<<endl<<a<<endl;
			cout<<pa<<endl;
		}
		实例解析char类型指针与其他类型指针的地址差异分析：
			int main() 
			{ 
				char x[10]= "tanzheng";
				char *x_pter=x;
				int y[8]= { 2,4,6,8,10,12,14,16 };
				int *y_pter=y;
				
				char *str1 = "abcdefdf";
				char *str2 = "abcdefdf";
				char *str3 = "abcdefdfg";
				
				std::cout << "Value of x variable: ";
				std::cout << x << std::endl;
				
				std::cout << "Value of &x[0] variable: ";
				std::cout << &x[0] << std::endl;
				
				std::cout << "Value of (void *)x variable: ";
				std::cout << (void *)x << std::endl;
				
				std::cout << "Value of &x variable: ";
				std::cout << &x << std::endl;
				
				std::cout << "Value of (void *)x[0] variable: ";
				std::cout << (void *)&x[0] << std::endl;
				
				std::cout << "Value of x_pter variable: ";
				std::cout << x_pter << std::endl;
				
				std::cout << "Value of (void *)x_pter variable: ";
				std::cout << (void *)x_pter << std::endl;
				
				std::cout << "Value of &x_pter variable: ";
				std::cout << &x_pter << std::endl;
				
				std::cout << "Value of y variable: ";
				std::cout << y << std::endl;
				
				std::cout << "Value of &y variable: ";
				std::cout << &y << std::endl;
				
				std::cout << "Value of &y[0] variable: ";
				std::cout << &y[0] << std::endl;
				
				std::cout << "Value of y_pter variable: ";
				std::cout << y_pter << std::endl;
				
				std::cout << "Value of &y_pter variable: ";
				std::cout << &y_pter << std::endl;
				
				if ((void *)str1 == (void *)str2) {
					std::cout << "(void *)str1 == (void *)str2" << std::endl;
				}
				else {
					std::cout << "(void *)str1 != (void *)str2" << std::endl;
				}
				std::cout << "Value of (void *)str1 variable: ";
				std::cout << (void *)str1 << std::endl;
				std::cout << "Value of (void *)str2 variable: ";
				std::cout << (void *)str2 << std::endl;
				std::cout << "Value of (void *)str3 variable: ";
				std::cout << (void *)str3 << std::endl;

				return 0;
			}
			Value of x variable: 				tanzheng
			Value of &x[0] variable: 			tanzheng
			Value of (void *)x variable:		00FEFE0C
			Value of &x variable: 				00FEFE0C
			Value of (void *)&x[0] variable: 	00FEFE0C
			Value of x_pter variable: 			tanzheng
			Value of (void *)x_pter variable:	00FEFE0C
			Value of &x_pter variable: 			00FEFE00
			Value of y variable: 				00FEFDD8
			Value of &y variable: 				00FEFDD8
			Value of &y[0] variable: 			00FEFDD8
			Value of y_pter variable: 			00FEFDD8
			Value of &y_pter variable: 			00FEFDCC
			(void *)str1 == (void *)str2
			Value of (void *)str1 variable: 	0038DC78
			Value of (void *)str2 variable: 	0038DC78
			Value of (void *)str3 variable: 	0038DC84
			
			1.为什么char*指针类型的x取地址时,需强制转换(void *)类型？其他类型的指针变量取地址时不需要强制转换？
				1)char*类型把字符串就是放在文字常量区,定义后不能修改且默认读取字符串数据,强制转换为(void *)类型,才能读取保存在文字常量区首地址.
				2)其他类型的指针(例如short int、long int)可直接取指针变量的地址.
			2.指针变量有几种形态？
				1)y表示指针y对应的内存空间(可以说就是指针本身的值)
	   			2)&y表示当前指针对应的内存空间的首地址(存放指针的地址)
	   			3)*y表示指针y所指向的变量对应的整个内存空间.(指针指向的空间)
	   		3.char*为什么能直接赋值字符串,常规操作时需要赋予指针地址？比如：char *str=“tanzheng”;
	   			1)字符串保存在文字常量区,编译时就确定了,程序运行时实际就是把保存“tanzheng”这个地址,赋值给指针变量str.
	   			2)把上述定义的指针变量赋值,比如：*str='A',会报错误.因为*str属于字符常量区,此内存区域只读不能写.
			4.定义连个字符串,比如：char *str1=“tanzheng”;char *str2=“tanzheng”,运行结果为：str1与str2的指针地址相等,为什么？
	   			1)相同的字符串在某些编译器中有相同的地址,比较是否为同一字符串时,可以比较地址是否相同.
	   				(注意：str1与str2的值不一定相同,这取决于编译器的行为.)
	   		5.声明char a[];出现报错？
	   			1)声明数组时,如果没有给变量初始化就必须指明数组的长,否则回报错.
	   		6.字符数组与字符指针的本质区别？比如：char a[] = "abcde";与char *b = "abcde";
	   			1)char 数组的初始化会将匿名数组(文字常量的字符串)的内容复制到对象所处的空间中,而 char* 的初始化器会将匿名数组(文字常量的字符串)的首地址赋值给对象.
			
第5章
91页
	对衔接的思考
		函数库、链接和载入
			
		警惕Interpositioning
			1.Interpositioning就是通过编写与库函数同名的函数来取代该函数的行为.
			2.同名函数会让程序调用时出错.
			准则;不要让程序中的任何符号成为全局的.除非有意把他们作为程序的接口之一.(通过把函数声明为static函数,使它在所在文件之外不可见或者另外取一个函数名字)
		
第6章
115页
	6.1 a.out及其传说
	6.2 段(segments)
		1.一个可执行文件有三个段:文本段(代码段)、数据段、bss段(Block Started by Symbol),可用size的命令查看段的大小.
			text指的是程序指令
			data指的是所有的经过初始化后的全局变量和静态变量
			bss段则是未经初始化的全局变量和静态变量,但是bss段不增加目标文件的大小,一般只是记录bss段的大小.
	6.4 堆栈段
		1.堆栈为函数内部的局部变量提供存储空间.
		2.进行函数调用时,堆栈存储与此有关的一些维护性信息.包括：函数调用地址、人和不适合装入寄存器的参数以及寄存器值得保存.
		3.堆栈也可以被用作暂存区.比如：计算一盒很长的算术表达式时,它可以把部分计算结果压到堆栈中,当需要时再把它从堆栈中取出.例如：alloca()函数分配内存就在堆栈中.
		
	6.8 setjmp和longjmp
		1.setjmp(jmp_buf j)必须首先被调用.表示“使用变量j记录现在的位置.函数返回0”
		2.longjmp(jmp_buf j,int i)可以接着被调用.它表示“回到j所记录的位置,让它看上去像是从原来的setjmp()函数返回一样,但是函数返回i,使代码能够知道它是通过longjmp返回的”
		3.当使用longjmp()时,j的内容被销毁.
		4.goto语句不能跳出C语言当前的函数(这也是“longjmp”取名的由来,它可以跳的很远,甚至可以跳到其他文件的函数之中).
		5.用longjmp只能跳回到曾经到过的地方.在执行setjmp的地方留下有一个过程活动记录.
		例如：
			#include "segjmp.h"
			jmp_buf j;
			#include "segjmp.h"
			
			banana() {
				printf("in banana() \n");
				longjmp(buf,1);
				/*以下代码不会被执行*/
				printf("you'll never see this,because i longjmp");
			}
			main()
			{
				if(setjmp(buf))
					printf("back in main \n");
				else {
					printf("first time through \n");
					banana();
				}
			}
			输出结果：
				first time through
				in banana()
				back in main
		注意：像goto一样,setjmp和longjmp使得程序难以理解和调试,如果不是出于特殊需要,最好避免使用它.
	
	6.11	有用的C语言工具
		1.
		
	6.12 
	
	6.13 汇编嵌入C代码中
		可以在汇编代码前冠以关键字“__asm”,也可以只使用关键字一次,把所有的汇编代码放入花括号内;
		例如：
			__asm {
				mov ah,2;
				mov dl,43h;
				int 21h;
			}
	
第7章(对内存的思考)			
137页
	内存速度的挑战大于内存速度.
	MS-DOC 640K的限制缘何而来：
		1.这个限制源于Inter8086这个最初的DOS机器的最大地址范围.8086支持20位地址,总共时1MB的内存,
		2.F0000到FFFFF          64KB,永久性的ROM区域BIOS、诊断信息等
		  D0000到EFFFF          128KB,用于ROM存储区域
		  C0000到CFFFF          64KB,用于BIOS扩展(XT硬盘)
		  B0000到BFFFF          64KB,用于常规性的内存显示
		  A0000到AFFFF          64KB,用于内存扩展
		  其余
		  00000到9FFFF          640KB,用于应用程序
	PC的内存模型
		MicrosoftC认可下面的内存模型：
			small		所有指针都为16位,代码和数据都限定在一个单一的段中,程序最大规模为128KB(代码段和数据段各64KB)
			large		所有指针都为32位,程序可以包含许多个64KB的段
			medium		代码指针为32位,所以代码段可能有多个.数据指针为16位,所以只有一个64KB的数据段.
		  	compact medium的另一种形式：代码指针为16位,所以代码最多不超过64KB.数据指针为32位,所以数据可以占据多个段,但堆栈里的数据仍限制在一个64KB的段内.
		MicrosoftC认可下面非标准的关键字：
			__near  16位指针
			__far   32位指针,但它所指的对象必须全部位于同一个段中(所有的对象均不得超过64KB)
			__huge  32位指针,上述所有的对段的限制都不存在
147页
	7.3 虚拟内存
		虚拟内存的基本思路是用廉价但缓慢的磁盘来扩充快速却昂贵的内存.
		运行下面程序,查询进程能分配多大的内存？
		例如：
			int main()
			{
				#if KB_DEFINE
					int KB=0;
					while(malloc(1 << 10)) ++KB;
					printf("Allocated %d KB totol\n", KB);
				#else
					int MB = 0;
					while (malloc(1 << 20)) ++MB;
					printf("Allocated %d MB totol\n", MB);
				#endif
					return 0;
			}
	7.4 Cache存储器(高速缓存SRAM)
		Cache存储器主要作用是缓解处理数据的两端速度不匹配这种情况带来的时间上的浪费,这样做就加快了访问速度.
		比如：大家都知道的cpu和内存之间的速度差异就特别大,所以需要cache缓存数据,以便提高速度.
		一级缓存：
			都内置在CPU内部并与CPU同速运行,可以有效的提高CPU的运行效率.一级缓存越大,CPU的运行效率越高,但受到CPU内部结构的限制,一级缓存的容量都很小.
		二级缓存：
			它是为了协调一级缓存和内存之间的速度.cpu调用缓存首先是一级缓存,当处理器的速度逐渐提升,会导致一级缓存就供不应求,这样就得提升到二级缓存了.二级缓存它比一级缓存的速度相对来说会慢,但是它比一级缓存的空间容量要大.主要就是做一级缓存和内存之间数据临时交换的地方用. [1] 
		三级缓存：
			是为读取二级缓存后未命中的数据设计的—种缓存,在拥有三级缓存的CPU中,只有约5%的数据需要从内存中调用,这进一步提高了CPU的效率.其运作原理在于使用较快速的储存装置保留一份从慢速储存装置中所读取数据并进行拷贝,当有需要再从较慢的储存体中读写数据时,缓存(cache)能够使得读写的动作先在快速的装置上完成,如此会使系统的响应较为快速. [2] 
		缓存的工作原理：
			是当CPU要读取一个数据时,首先从缓存中查找,如果找到就立即读取并送给CPU处理;如果没有找到,就用相对慢的速度从内存中读取并送给CPU处理,同时把这个数据所在的数据块调入缓存中,可以使得以后对整块数据的读取都从缓存中进行,不必再调用内存.
		保证命中率的算法：
			为了保证CPU访问时有较高的命中率,缓存中的内容应该按一定的算法替换.
			一种较常用的算法是“最近最少使用算法”(LRU算法),它是将最近一段时间内最少被访问过的行淘汰出局.
			因此需要为每行设置一个计数器,LRU算法是把命中行的计数器清零,其他各行计数器加1.
			当需要替换时淘汰行计数器计数值最大的数据行出局.这是一种高效、科学的算法,其计数器清零过程可以把一些频繁调用后再不需要的数据淘汰出缓存,提高缓存的利用率.
		主存和cache如何一一对应？
			主存(DRAM)与Cache(SRAM)的地址都为块号+块内地址,
			CPU如果从主存里面取数据发送的是主存的地址,通过地址里面的块号与cache存储器里面的块号匹配,如果相等命中成功.	
						
	7.5 数据段和堆
		堆
			1.堆区域用于动态分配的存储,通过malloc函数获得的内存.并通过指向访问.
			2.从堆中获取内存的唯一办法就是通过调用malloc(以及同类的calloc、realloc等)库函数.
			  calloc函数与malloc类似,它在返回指针之前,先把分配的内存内容清空为0.
			  realloc函数改变一个指针所指向内存块的的大小,即可以将其扩大,也可以把它缩小.
			3.malloc和free → 从堆中获得内存以及把内存返回给堆.
			  brk和sbrk → 调整数据段的大小至一个绝对值(通过某个增量).
	
	7.6 内存泄漏
		这些C程序在使用malloc()和free()时不得不慎重.堆经常会出现两种类型的问题：
			1.释放和改写仍在使用的内存(称为"内存损坏").
			2.未释放不再使用的内存(称为"内存泄漏")	
		避免内存泄漏
			1.每次当调用malloc分配内存时,注意在以后要调用相应的free来释放它.
			2.也可调用alloca()来分配动态内存,当离开alloca()函数时,分配的内存自动释放,但不适用于函数周期超过创建函数的时间,且移植性不好,建议不用!!
		malloc()函数分配内存的注意事项：
			1.malloc()函数所分配的内存通常会圆整未一个大于申请数量的2的整数次方(如申请212B,会圆整为256B).
		如何检测内存泄漏：
			第一步(检测内存是否泄漏)：
				1.首先,使用swap命令观察还有多少可用的交换空间：
					/usr/sbin/swap -s
					totol：17228Kbyte allocated + 5396k reserved = 22624K uesd,29548K available;
				2.在一两分钟内键入该命令3到4次,看看可用的交换区是否在减少,还可以使用其他一起/use/bin/*stat工具如netstat、vmstat等.
				3.如果发现不断的有内存被分配且从不释放,一个可能的解释就是有个进程出现了内存泄漏.
			第二步(确定可疑进程)
				1.可以使用“pa-lu 用户名”命令来显示所有进程的大小,如下所示：
					F		S		UID		PID		PPID		C		PRI		NI		ADDR		SZ		WCHAN		   TTY		TIME		COMD
					8		S		5303	226		224			80	1			20	FF38F000	199		ff38f1d0   pts/3  0:01		csh
					8		O		5303	921		226			29	1			20	FF38C000	143		           pts/3  0:00		ps
				2.标题SZ的列就是以页面表示的进程大小(如果想知道以KB表示的页面大小,可以用pagesize命令)
				3.同样数次重复这个命令,可以发现任何动态分配内存的进程的大小都在变化.如果一个进程看上去不断地增长而从不缩小,它就有可能出现”内存泄漏“
		运用malloc()函数的理由：
			1.系统经常可以使用不同的malloc函数,有些在运行速度上作了优化.
			2.有些则重视空间的充分利用.
			3.有些对调试有所帮助.
		查询malloc()函数：
			键入命令：man -s 3c malloc,可以游览主文档页面,观察所有malloc系列函数.
		内存泄漏的后果：
			当内核程序请求内存时,他们通常会进行等待,知道有足够的内存可分配;如果出现内存泄漏,最终可能导致无限制等待-于是机器便会挂起.
			
	7.7 总线错误
		常见的运行错误：
			bus error(core dumped)	总线错误(信息已转存)
			和
			segmentation fault(core dumped)	段错误(信息已转存)
			
		7.71 总线错误
			总线错误的原因：
				总线错误几乎都是由于未对齐的读和写引起的.因为出现未对齐的内存访问请求时,被堵塞的组建就是地址总线.
			对齐的含义：
				对齐的含义就是数据项只能存储在地址是数据项大小的整数倍的内存位置上.
				例如：
					访问一个8字节的double数据时,存储地址只允许是8的整数倍.所以数据可以存储于地址：24、8008或32768,但不能存储于1006(因为无法被8整除)
			举例一个总线错误的小程序：
				例如：
					union {
						char a[10];
						int i;
					} u;
					int *p = (int *)&(u.a[1]);
					*p = 17;				/*p中未对齐的地址会引起总线错误!*/
			编译器如何应对内存不对齐的程序？
				1.一个好的编译器能发现不对齐的情况且发出警告,但它并不能检测到所有不对齐的状况.
				2.部分编译器通过自动分配和填充数据来进行对齐;另外一些编译器不会自动对齐,就用一条STR来写入,那必然异常.
				3.指针小转大(u8转u16,u16转u32等)应该被严格禁止的.因为很有可能出现访问不对齐出错.
				4,对齐的数据能提高效率,为了访问未对齐的内存,处理器需要作两次内存访问;而对齐的内存访问仅需要一次访问.
			阐述几种对齐的规则：
				1.数据类型自身的对齐值：对于char型数据,其自身对齐值为1字节,对于short型为2字节,对于
				  int,float,double类型,其自身对齐值为4字节.
				2.结构体的自身对齐值：其成员中自身对齐值最大的那个值.
				3.指定对齐值： #pragma   pack(n)来设定变量以n字节对齐方式.n字节对齐就是说变量存放的起始地址的偏移量有两种情况,
				  第一、如果n大于等于该变量所占用的字节数,那么偏移量必须满足默认的对齐方式,
				  第二、如果n小于该变量的类型所占用的字节数,那么偏移量为n的倍数,不用满足默认的对齐方式.
				4.数据成员和结构体的有效对齐值：数据成员(数据类型)和数据结构的自身对齐值和指定对齐值中小的那个值,数据成员对齐了数据结构自然也就对齐了.

		7.72 段错误
			如果指针引用一个并不位于你的地址空间的地址,操作系统会阻止,引起段错误的程序如下：
			例如：	
				int *p = 0;
				*p = 17;    /* 引起一个段错误 */
				
			SunOS中的一个段违规Bug：
				问题症状：无法运行printf,直接原因是引用一个空指针引起的段违规,问题语句如下：
					(void)printf("%s",p->name);
				解决方案1(新手用啰嗦的修正办法)
					if(p->name != NULL)
					{
						(void)printf("%s",p->name);
					}
					else
					{
						(void)printf("NULL");
					}
				解决方案2(可以用条件操作符,即可简化代码,又可保持引用的局部性)
					(void)printf("%s",p->name ? p->name : "NULL");		/* 输出字符串 */
					
			通常导致段错误的几个直接原因：
				* 解除引用一个包括非法值的指针.
				* 解除引用一个空指针(常常由于从系统程序中返回空指针,并未经检查就使用).
				* 在未得到正确的权限时进行访问.例如：试图往一个只读的文本段写数据导致段错误.
				* 用完了堆栈和堆空间(虚拟内存虽然巨大但绝非无限).
				以发生频率为序,导致段错误的常见编程错误是：
					1.野指针值错误:
						1)在指针赋值之前就用来引用内存,或向库函数传送一个野指针,引起段错误.
						2)对指针进行释放之后再访问它的内容,导致段错误.可以在free函数后,即释放指针后再将它置为NULL.
							例如：free(p);
								  p = NULL;
					2.重写(overwrite)错误:
						1)再数组边界外写入数据,再动态分配的内存两端以外写入数据,或改写一些堆管理数据的结构.(在动态分配内存之前的写入数据很容易发生次错误)
							例如：p=malloc(256);
								  p[-1]=0;			
								  p[256]=0;			/* -1和256都越界了 */
					3.指针释放引起的错误:
						1)释放同一内存块两次及以上
						2)释放一块未曾使用malloc分配的内存(未用malloc函数分配的内存块,就调用free函数释放!)
						3)释放仍在使用中的内存
						4)释放一个无效的指针
					4.在链表中释放元素:
						在遍历链表时正确释放元素的方法是使用临时变量存储下一个元素地址,这样就安全地在任何时候释放当前元素,
						不必担心在取下一个元素地址时还要引用它，代码如下：
							失败的案例：
								struct node *start,*p;
								for(p = start;p;p = p->next) {
									free(p);									/* p = p->next语句,程序对已经释放的指针进行解除指针操作 */
								}		
								
							正确的案例：
								struct node *start,*p,*tmp;
								for(p = start;p;p = tmp) {
									tmp = p->next;
									free(p);
								}
				
		7.8 轻松一下 ————"Thing King"和"页面游戏"
			规则：
			1.每个进程拥有几百万的“字节”。
			2.字节存放于“页”中，每页4096个字节。位于同一页上的字节具有"本地引用“关系。
			3.页可以存放在内存中，也可以放在磁盘中，内存一般不够大，无法容纳所有的页。
			4.总共只有一块内存，但可以有几个磁盘，所有进程共享内存和磁盘。
			5.每个字节都有自己的虚拟地址。
			6.进程可以对一个字节进行“引用操作”。每个字节轮流进行引用操作。
			7.每个进程只能引用自己的字节，不能引用其进程的字节。
			8.字节只有当他们位于内存中时才能被引用。
			9.只有”虚拟内存管理器“知道某个字节位于内存还是磁盘。
			10.一个字节不被引用的时间越长，它就被称为越”旧“。
			11.进程必须通过“虚拟内存管理器”得到内存。它所给的字节数量是2的倍数或乘方数，这有助于减少开销。
			12.进程引用字节的方法就是给出它的虚拟地址。如果进程给出的虚拟地址恰好位于内存中，那么进程就可以立即引用它、
			   如果它位于磁盘，虚拟内存管理器会把它包含该字节的页移入内存中，如果内存空间已满，它就寻找内存中最旧的页
			   （可能是该进程自己的，也可能是其他进程的），把它换到磁盘中，腾出的空间就存放包含你需要字节的页。然后进程
			   就可以引用该字节，当进程并不知道该页原先位于磁盘中。
			13.每个进程拥有的字节的虚拟地址与其他进程一样，虚拟内存管理器始终知道谁拥有哪个字节以及该轮到谁进行引用操作，
			   所以一个进程不会无意引用其他进程的字节，即使两者的虚拟地址相同。
			
			说明
			1.根据传统，虚拟内存使用一张很大且分段的表，另外还有页表记住所有字节的位置以及它们的主人。
			2.规则13的结果就是各自运行中每个进程的虚拟地址都类似，即使进程的数量有变化。
			3.虚拟内存管理器也拥有自己的一些字节，它们中的有些也和进程的字节一样在内存和磁盘中移来移去，但是，
			  它的有些字节使用频率非常之高，所以常驻内存。
			4.按照上述规则，经常引用的字节更有可能被存放在内存中，而不太被引用的字节更有可能存放在磁盘中，这可以提高内存的使用效率。
			
			解决方案：
			捕捉段错误信号和信号处理程序
			例如：
				#include <signal.h>
				#include <stdio.h>
				
				void handler(int s)
				{
					if(s == SIGBUS) printf(" now got a bus error signal\n");
					if(s == SIGSEGV) printf(" now got a segmentation violation signal\n");
					if(s == SIGILL) printf(" now got a illegal instrution signal\n");
					exit(1);
				}
				void main()
				{
					int *p = NULL;
					signal(SIGBUS,handler);
					signal(SIGSEGV,handler);
					signal(SIGILL,handler);
					*p = 0;						/* 非法内存访问，会产生SIGSEGV信号，打印对应的提示信息 */
				}
				运行改程序，输出结果如下：
				% a.out
					now got a segmentation violation signalow 
			
第8章（为什么程序员无法分清万圣节和圣诞节）
169页
	8.2 根据位模式构筑图形
		图标或图形，是一种小型的位模式映射于屏幕产生的图像。一个位代表图形的一个像素。
		C语言中，典型的16*16的黑白图形可能如下：
			static unsigned short stopwatch[] = {
				0x07C6,
				0x1FF7,
				0x383B,
				0x500C,
				0x500C,
				0xC006,
				0xC006,
				0xDF06,
				0xC106,
				0xC106,
				0x510C,
				0x510C,
				0x3838,
				0x1FF0,
				0x07C0,
				0x0000
			};
			上面的C语言常量并未提供有关图形实际模样的任何线索。这里有一个惊人的#define定义的优雅集合，
			允许程序建立常量使它们看上去像是屏幕上的图形。
			#define X )*2+1
			#define _ )*2
			#define s ((((((((((((((((0			/* 用于创建16位宽的图形 */
			/* 使用上面的宏定义，程序就可以描述出对应的图形，程序的自描述能力大大加强 */
			static unsigned short stopwatch[] = 
			{
				s _ _ _ _ _ X X X X X _ _ _ X X _,
				s _ _ _ _ _ X X X X X _ _ _ X X _,
				s _ _ X X X _ _ _ _ _ X X X _ X X,
				s _ X X _ _ _ _ _ _ _ _ _ X X _ _,
				s _ X X _ _ _ _ _ _ _ _ _ X X _ _,
				s X X _ _ _ _ _ _ _ _ _ _ _ X X _,
				s X X _ _ _ _ _ _ _ _ _ _ _ X X _,
				s X X _ X X X X X _ _ _ _ _ X X _,
				s X X _ _ _ _ _ X _ _ _ _ _ X X _,
				s X X _ _ _ _ _ X _ _ _ _ _ X X _,
				s _ X X _ _ _ _ X _ _ _ _ X X _ _,
				s _ X X _ _ _ _ X _ _ _ _ X X _ _,
				s _ _ X X X _ _ _ _ _ X X X _ _ _,
				s _ _ _ X X X X X X X X X _ _ _ _,
				s _ _ _ _ _ X X X X X _ _ _ _ _ _,
				s _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
			};
			注意：千万不要忘记在绘图结束后清除这些宏定义，否则可能会给你后面的代码带来不可预测的后果。
					#ifdef X
						#undef X
					#endif
					/*------*/
					#ifdef _
						#undef _
					#endif
					/*------*/
					#ifdef s
						#undef s
					#endif
					/*------*/
					
		C语言实例：
			#include	<stdio.h>
			
			#define X )*2+1
			#define _ )*2
			#define s ((((((((((((((((0			/* 用于创建16位宽的图形 */
			/* 使用上面的宏定义，程序就可以描述出对应的图形，程序的自描述能力大大加强 */
			static unsigned short stopwatch[] =
			{
			#if 1
				s _ _ _ _ _ X X X X X _ _ _ X X _,
				s _ _ _ _ _ X X X X X _ _ _ X X _,
				s _ _ X X X _ _ _ _ _ X X X _ X X,
				s _ X X _ _ _ _ _ _ _ _ _ X X _ _,
				s _ X X _ _ _ _ _ _ _ _ _ X X _ _,
				s X X _ _ _ _ _ _ _ _ _ _ _ X X _,
				s X X _ _ _ _ _ _ _ _ _ _ _ X X _,
				s X X _ X X X X X _ _ _ _ _ X X _,
				s X X _ _ _ _ _ X _ _ _ _ _ X X _,
				s X X _ _ _ _ _ X _ _ _ _ _ X X _,
				s _ X X _ _ _ _ X _ _ _ _ X X _ _,
				s _ X X _ _ _ _ X _ _ _ _ X X _ _,
				s _ _ X X X _ _ _ _ _ X X X _ _ _,
				s _ _ _ X X X X X X X X X _ _ _ _,
				s _ _ _ _ _ X X X X X _ _ _ _ _ _,
				s _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
			#else
				s _ _ _ _ _ X X X X X _ _ _ X X _,
				s _ _ _ _ _ X X X X X _ _ _ X X _,
				s _ _ X X X _ _ X _ _ X X X _ X X,
				s _ X X _ _ _ _ X _ _ _ _ X X _ _,
				s _ X X _ _ _ _ X _ _ _ _ X X _ _,
				s X X _ _ _ _ _ X _ _ _ _ _ X X _,
				s X X _ _ _ _ _ X _ _ _ _ _ X X _,
				s X X X X X X X X X X X X X X X _,
				s X X _ _ _ _ _ X _ _ _ _ _ X X _,
				s X X _ _ _ _ _ X _ _ _ _ _ X X _,
				s _ X X _ _ _ _ X _ _ _ _ X X _ _,
				s _ X X _ _ _ _ X _ _ _ _ X X _ _,
				s _ _ X X X _ _ _ _ _ X X X _ _ _,
				s _ _ _ X X X X X X X X X _ _ _ _,
				s _ _ _ _ _ X X X X X _ _ _ _ _ _,
				s _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
			#endif
			};
			
			#define ushort_bit_length 16
			void main()
			{
				int buf_length;
				buf_length = sizeof(stopwatch)/2;
				printf("buf_length = %d\n", buf_length);
				printf("\n");
			
				for (int i = 0; i < buf_length; i++)
				{
					for (int j = 0; j < ushort_bit_length; j++)
					{
						if (j == 0)
						{
							printf("s");
						}
						else
						{
							if ((stopwatch[i] << j) & 0x8000)
							{
								printf("X");
							}
							else
							{
								printf("_");
							}
						}
					}
					printf("\n");
				}
				printf("\n");
			
				#ifdef X
					#undef X
				#endif
			
				#ifdef _
					#undef _
				#endif
			
				#ifdef s
					#undef s
				#endif
			
				#ifdef X
					printf("#ifdef X able\n");
				#else
					printf("#undef X able\n");
				#endif
			
				#ifdef _
					printf("#ifdef _ able\n");
				#else
					printf("#undef _ able\n");
				#endif
			
				#ifdef s
					printf("#ifdef s able\n");
				#else
					printf("#undef s able\n");
				#endif
			}

	8.4 原型之痛
		
	8.5 原型在什么地方会失败
		不要再函数的声明和定义中混用新旧两种风格
			1.坚决不要再函数声明和定义中混用新旧两种风格。如果函数在头文件中的声明是K&R
				C风格的，那么函数的定义也应该使用K&R C风格的语法。
				例：int foo();	
						int foo(a,b) 
						int a;
						int b;
						{
							;
						}
			2.如果函数具有ANSI C原型,那么在它的定义中也使用ANSI C风格语法。
				例：int foo(int a,int b);	
						int foo(int a,int b) 
						{
							;
						}
		
	8.6 不需要按回车键就能得到一个字符
		Micorsoft和Borland的C编译器提供了getch()（或getche()，它可以使字符在读取的同时回显于屏幕上）来获取单个字符，而不用等待整行结束。
		Windows 系统下的 vs 中可以使用 _kbhit() 函数来获取键盘事件，使用时需要加入 conio.h 头文件。
		
		C/C++ 获取键盘事件
			1.Windows 系统下的 vs中的用法：
				#include <conio.h>
				#include <iostream>
				 
				using namespace std;
				 
				int main()
				{
					int ch;
					while (1){
						if (_kbhit()){//如果有按键按下，则_kbhit()函数返回真
							ch = _getch();//使用_getch()函数获取按下的键值
							cout << ch;
							if (ch == 27){ break; }//当按下ESC时循环，ESC键的键值时27.
						}
					}
					system("pause");
				}
			2.在 Unix/Linux 下，并没有提供 kbhit() 函数。我们可以自己来实现 kbhit() 程序。
			  在UNIX中，有两种方法实现逐字符的输入，一种很难，一种很容易。
				1）.容易的方法让stty程序来实现这个功能：（通过终端命令的方式间接实现）
					#include <stdio.h>
					main()
					{	
						int c;
						system("stty raw");			/* 终端驱动处于一次一个字符模式 */
						c = getchar();
						system("stty cooked");		/* 终端驱动处又回到一次一行模式 */
					}
					总结：
						a.最后一行不能省略system("stty cooked");因为程序结束后，终端字符驱动特性还会延续下去。
						  这和设置环境变量明显不同，后者在进程结束后自动消失。
						b.此方法把I/O设置为raw状态实现阻塞式读入，如果终端没有字符输入，进程就一直等待，直到字符输入为止。
				2）.此方案可实现非阻塞式读入，使用ioctl()（I/O控制）系统调用。此函数可判断是否有按键按下,通过轮询判断按键按下，才进行字符读入：
					//#include <sys/filio.h>	/* 此头文件在Linux下Ubuntu系统编译出错，可能只能用于Unix系统，用<sys/ioctl.h>替代 */		
					#include <sys/ioctl.h>		/* BSD and Linux，ioctl()函数的头文件 */
					#include <errno.h>			/* errno变量的头文件 */
					#include <stdio.h>
					
					int kbhit()
					{
						int i;
						
						errno=0;				/* 如果库函数调用或系统调用遇到问题时，errno变量被设置以提示问题原因 */	
						if(ioctl(0,FIONREAD,&i) < 0) {
							if(errno == EBADF) printf("errno: bad file number");
							if(errno == EINVAL) printf("errno: invalid argument");
						}
						return i;
					}
					main()
					{	
						int i = 0;
						char c=' ';
						
						system("stty raw -echo");		/* 终端驱动处于一次一个字符模式且关闭回显 */
						printf("input 'q' quit \n");	/* printf()函数内如果不加"\n"，可能导致终端设备不显示此内容 */
						for(;c!='q';i++) {
							if(kbhit()) {
								c = getchar();
								printf("\n got %c,on iteration = %d",c,i);
							}
						}
						system("stty cooked echo");		/* 终端驱动处又回到一次一行模式且打开回显 */
					}
				
		Linux/Unix下广泛应用的图形函数库curses,取代stty命令，改写上面的main函数代码：
			#include <curses.h>			/* 使用curses函数库和前面定义的kbhit()函数 */
			#include <errno.h>
			#include <sys/ioctl.h>
			
			int kbhit()
			{
				int i;
			
				errno=0;
				if(ioctl(0,FIONREAD,&i) < 0) {
					if(errno == EBADF) printf("errno:bad file number");
					if(errno == EINVAL) printf("errno: invalid argument");
				}
				return i;
			}
			main()
			{
				char c=' ';
				int i = 0;
				
				initscr();				/* 初始化curses函数 */
				cbreak();
				noecho();				/* 按键时不在屏幕回显字符 */
				mvprintw(0,0,"Press 'q' quit \n");
				refresh();
				
				while(c != 'q') {
					if(kbhit()) {
						c = getchar();	/* 不会阻塞，因为我们知道有个字符正在等待 */
						mvprintw(1,0,"got %c,on iteration %d \n",c,++i);
						refresh();
					}
				}
				nocbreak();
				echo();
				endwin();				/* 结束curses进程 */
			}
			总结：
				a.可以直接在usr/include下查看是否有该头文件<curses.h>，如果没有需安装curses库（>sudo apt-get install ncurses-dev ），
				  curses函数库的头文件和库文件就被分别安装在/usr/include/和/usr/lib/下。
				b.在编译程序时，直接使用命令：gcc program.c -o program -lcurses，完成编译，运行。
			
	8.7 用C语言实现有限状态机
		1.有限状态机（Finite-state machine）是一个非常有用的模型，可以模拟世界上大部分事物，它有三个特征：
		　　* 状态总数（state）是有限的。
		　　* 任一时刻，只处在一种状态之中。
		　　* 某种条件下，会从一种状态转变（transition）到另一种状态。
		2.基本思路是一张表保存所有可能的状态，并列出每个状态可能执行的所有动作，其中最后一个动作就是
		  计算（通常当前状态和下一次输入字符的基础上，另外在经过一次表查询）下一个应该进入的状态。
		3.在C语言中，有好几种方法可以表达FSM，但绝大多数都是基于函数指针数组,具体如下：
		  a.一个函数指针数组可以如下声明：
		  	void (*state[MAX_STATES])();
		  b.如果知道了数组名，可以用下面方式进行初始化：
		  	extern int a(),b(),c(),d();
		  	int (*state[])() ={ a,b,c,d };
		  c.可以通过数组指针来调用函数：
		    (*state[i])();
		  注意：所有函数必须接收同样的参数，并返回同样类型的返回值（除非把数组元素做一个联合），
		4.如果想设计的更漂亮，可以让状态函数返回一个指向通用后续函数的指针，并把它转换为适当的类型。
		  这样就不需要全局变量。如果不想太花哨，可以使用switch语句作为简朴的状态机。
		5.关于FSM还有最后一点说明：如果你的状态函数需要多个不同的参数，可以考虑使用参数计数器和一个字符串指针数组，
		  就像main函数的参数一样，我们熟悉的int argc；char *argv[]机制非常普遍，可以成功的运用在你所定义的函数中。
		
	8.8 软件比硬件困难
		1.FMS编写代码时使用两个明显的阶段：
		  a.首先进行状态切换，只有当他们处于工作状态时才提供动作。
		  b.可调式性代码的方式构建框架：把系统分成几个部分，先让程序总体运行。只有基本的程序运行后，你才为那些复杂的细节完善、性能调整和算法优化进行编码。
		2.运用可调式编码方式实现“散列函数”：
		  a.先完成最简单能运行的程序，就是散列函数总是返回0：
		  	/* hash_file:占位符s为将来更复杂的程序预留位置 */
		  	int hash_filename(char *s) {
		  		return 0;
		  	}
		    调用这个散列函数的程序如下：
		    /**
		     * find_file:定位以前建立的文件描述符，需要时可以新建一个
		     */
		    file find_filename(char *s)
		    {
		    	int hash_value = hash_filename(s);
		    	file f;
		    	for(f = file_hash_table[hash_value];f != NIL;f = f -> flink) {
		    		if(strcmp(f->fname,s) == SAME) {
		    			return f;
		    		}
		    	}
		    	
		    	f = allocate_file(s);
		    	f->flink = file_hash_table[hash_value];
		    	file_hash_table[hash_value] = f;
		    	return f;
		    }
		    上述效果像是一个散列表还未被使用，所有元素存储在第0个元素后面的链表之中。使得函数很容易实现和调试，因为无需实现散列函数的具体值，
		    下面实现hash_filename()函数：
		    int hash_filename(char *s) {
		    	int length = strlen(s);
		    	return (length+4*(s[0]+4*s[length/2])) / FILE_HASH;
		    }
		3.编程挑战：（把上述编程片段补充完整，实现散列函数）
			#include <stdio.h>
			#include <stdlib.h>
			#include <string.h>
			
			#define TABLE_SIZE (16)		// TABLE_SIZE赋值为16或者2的幂次；否则，不能通过data & (TABLE_SIZE-1)计算索引值（data % TABLE_SIZE的方式计算索引值）
        	
            /* hash表和基本数据节点 */
            typedef struct _node {
				int data;
				struct _node* next;
			} NODE;
			
			typedef struct _hash_table {
				NODE* value[TABLE_SIZE];
			} HASH_TABLE;
			
			typedef enum {
				FALSE = 0,
				TRUE
			}STATUS;
			
            /* 创建hash表 */
			HASH_TABLE* create_hash_table()
			{
				HASH_TABLE* pHashTb1 = (HASH_TABLE*)malloc(sizeof(HASH_TABLE));
				memset(pHashTb1, 0, sizeof(HASH_TABLE));
				return pHashTb1;
			}
            
            /* 在hash表当中寻找数据 */
			NODE* find_data_in_hash(HASH_TABLE* pHashTbl, int data)
			{
				int i=0;
				NODE* pNode;
				if (NULL == pHashTbl)
					return NULL;
			
				//if (NULL == (pNode = pHashTbl->value[data % TABLE_SIZE]))
				if (NULL == (pNode = pHashTbl->value[data & (TABLE_SIZE - 1)]))
					return NULL;
			
				while (pNode){
					if (data == pNode->data)
						return pNode;
					pNode = pNode->next;
					i++;
				}
				return NULL;
			}
            
            /* 在hash表当中插入数据 */
			STATUS insert_data_into_hash(HASH_TABLE* pHashTbl, int data)
			{
				NODE* pNode;
				if (NULL == pHashTbl)
					return FALSE;
			
				//if (NULL == pHashTbl->value[data % TABLE_SIZE]){
				if (NULL == pHashTbl->value[data & (TABLE_SIZE - 1)]){
					pNode = (NODE*)malloc(sizeof(NODE));
					memset(pNode, 0, sizeof(NODE));
					pNode->data = data;
					//pHashTbl->value[data % TABLE_SIZE] = pNode;
					pHashTbl->value[data & (TABLE_SIZE - 1)] = pNode;
					return TRUE;
				}
			
				if (NULL != find_data_in_hash(pHashTbl, data))
					return FALSE;
			
				//pNode = pHashTbl->value[data % TABLE_SIZE];
				pNode = pHashTbl->value[data & (TABLE_SIZE - 1)];
				while (NULL != pNode->next)
					pNode = pNode->next;
			
				pNode->next = (NODE*)malloc(sizeof(NODE));
				memset(pNode->next, 0, sizeof(NODE));
				pNode->next->data = data;
				return TRUE;
			}
            
            /* 从hash表中删除数据 */
			STATUS delete_data_from_hash(HASH_TABLE* pHashTbl, unsigned long int data)
			{
				NODE* pHead;
				NODE* pNode;
				//if (NULL == pHashTbl || NULL == pHashTbl->value[data % TABLE_SIZE])
				if (NULL == pHashTbl || NULL == pHashTbl->value[data & (TABLE_SIZE - 1)])
					return FALSE;
			
				if (NULL == (pNode = find_data_in_hash(pHashTbl, data)))
					return FALSE;
			
				//if (pNode == pHashTbl->value[data % TABLE_SIZE]){
				if (pNode == pHashTbl->value[data & (TABLE_SIZE - 1)]){
					//pHashTbl->value[data % TABLE_SIZE] = pNode->next;
					pHashTbl->value[data & (TABLE_SIZE - 1)] = pNode->next;
					goto final;
				}
			
				//pHead = pHashTbl->value[data % TABLE_SIZE];
				pHead = pHashTbl->value[data & (TABLE_SIZE - 1)];
				while (pNode != pHead->next)
					pHead = pHead->next;
				pHead->next = pNode->next;
			
				final:
				free(pNode);
				return TRUE;
			}
			
			/* the classic Times33 hash function */
			static int hash_33(char* key)
			{
				int hash = 0;
				while (*key) {
					hash = (hash << 5) + hash + *key++;
					//hash = hash * 33 + *key++;
				}
				return hash;
			}
			
			void main()
			{
				NODE* p_node = NULL;
				HASH_TABLE* p_hash_table = NULL; 
				STATUS e_status;
				int hash_code;
				char input[] = "book";
				char input2[] = "tanzheng";
			
				p_hash_table = create_hash_table();
				if (p_hash_table != NULL) {	
					printf("create hash_table ok,address=%p \n", p_hash_table);
					hash_code = hash_33(input);
					e_status = insert_data_into_hash(p_hash_table, hash_code);
					e_status = insert_data_into_hash(p_hash_table, hash_code);
					e_status = insert_data_into_hash(p_hash_table, 16139);
					e_status = insert_data_into_hash(p_hash_table, 7723);
					e_status = insert_data_into_hash(p_hash_table, 7724);
					e_status = insert_data_into_hash(p_hash_table, 7725);
                    e_status = delete_data_from_hash(p_hash_table, 16139);
                    e_status = delete_data_from_hash(p_hash_table, 7724);
					if (e_status == TRUE) {
						printf("SUCCESS \n");
					}
					else {
						printf("FAILURE \n");
					}
				}
			}
			注意：1.TABLE_SIZE赋值为16或者2的幂次；否则，不能通过data & (TABLE_SIZE-1)计算索引值（data % TABLE_SIZE的方式计算索引值）。
				  2.Hash算法最终得到的index结果，完全取决于Key的Hashcode值的最后几位。（上述的Hashcode算法用的hash_33()函数）。
				  3.Hash碰撞时，运用链表保存对应的索引结构下,称为"链式扩展"。
                  4.HashMap负载因子，默认值为0.75f。当HashMap.Size≥0.75*TABLE_SIZE，需要扩展TABLE_SIZE的大小；防止Key映射位置发生冲突的几率降低。
                
		 4.补充知识（strlen与sizeof的区别？）
			a.sizeof
				sizeof(...)是运算符，在头文件中typedef为unsigned int，其值在编译时即计算好了，参数可以是数组、指针、类型、对象、函数等。
				它的功能是：获得保证能容纳实现所建立的最大对象的字节大小。
				由于在编译时计算，因此sizeof不能用来返回动态分配的内存空间的大小。实际上，用sizeof来返回类型以及静态分配的对象、结构或数组所占的空间，返回值跟对象、结构、数组所存储的内容没有关系。
				具体而言，当参数分别如下时，sizeof返回的值表示的含义如下：
				数组——编译时分配的数组空间大小；
				指针——存储该指针所用的空间大小（存储该指针的地址的长度，是长整型，应该为4）；
				类型——该类型所占的空间大小；
				对象——对象的实际占用空间大小；
				函数——函数的返回类型所占的空间大小。函数的返回类型不能是void。
				**************
			b.strlen
			    strlen(...)是函数，要在运行时才能计算。参数必须是字符型指针（char*）。当数组名作为参数传入时，实际上数组就退化成指针了。
			    它的功能是：返回字符串的长度。该字符串可能是自己定义的，也可能是内存中随机的，该函数实际完成的功能是从代表该字符串的第一个地址开始遍历，直到遇到结束符NULL。返回的长度大小不包括NULL。
			c.举例：
			    eg1.char arr[10] = "What?";
		            int len_one = strlen(arr);
		            int len_two = sizeof(arr); 
		            cout << len_one << " and " << len_two << endl; 
			    	输出结果为：5 and 10
			    	点评：sizeof返回定义arr数组时，编译器为其分配的数组空间大小，不关心里面存了多少数据。strlen只关心存储的数据内容，不关心空间的大小和类型。
			    eg2.char * parr = new char[10];
			        int len_one = strlen(parr);
			        int len_two = sizeof(parr);
			        int len_three = sizeof(*parr);
			        cout << len_one << " and " << len_two << " and " << len_three << endl;
			        输出结果：23 and 4 and 1
			        点评：第一个输出结果23实际上每次运行可能不一样，这取决于parr里面存了什么（从parr[0]开始知道遇到第一个NULL结束）；第二个结果实际上本意是想计算parr所指向的动态内存空间的大小，但是事与愿违，sizeof认为parr是个字符指针，因此返回的是该指针所占的空间（指针的存储用的是长整型，所以为4）;第三个结果，由于*parr所代表的是parr所指的地址空间存放的字符，所以长度为1。
			        ************
			        
	8.9 如何进行强制类型转换，为何要进行类型强制转换
		1.复杂的类型转换可以按3各步骤编写：
			1）一个对象的声明，它的类型就是想要转换的结果类型。
			2）删除标识符（以及任何和extern之类的存储限定符），并把剩余的内容放在一对括号里。
			3）把第2步产生的内容放在需要进行类型转换的对象左边。
		2.举例：
			1）建立一个指向printf()函数的指针：
				extern int printf(const char*,...);
				void main()
				{
					void* f = (void*)printf;
					(*(int(*)(const char*,...))f)("I'm ok! \n");
				}
				或
				extern int printf(const char*,...);
				typedef int(*p_function)(const char*,...);
				void main()
				{
					p_function f;
					f = &printf;
					(*f)("I'm ok! \n");
				}
			2）void和void*指针使用规范:
				void和void*指针的含义：
					void的字面意思是“无类型”，void*则为“无类型指针”，void*可以指向任何类型的数据。void几乎只有“注释”和限制程序的作用，因为从来没有人会定义一个void变量。
				规则一：如果函数没有返回值，那么应声明为void类型
				规则二：如果函数无参数，那么应声明其参数为void
				规则三：小心使用void指针类型
					   解释：a.在ANSIC标准中，不允许对void指针进行算术运算如pvoid++或pvoid+=1等，而在GNU中则允许，
				               因为在缺省情况下，GNU认为void *与char *一样。sizeof(*pvoid )== sizeof( char)。
				             b.void指针可以指向任意类型的数据，亦即可用任意数据类型的指针对void指针赋值。例如：
							   int * pint;
							   void *pvoid;
							   pvoid = pint; /* 不过不能 pint= pvoid; */
							   如果要将pvoid赋给其他类型指针，则需要强制类型转换如：pint= (int *)pvoid;
				规则四：如果函数的参数可以是任意类型指针，那么应声明其参数为void*
					   解释：典型的如内存操作函数memcpy和memset的函数原型分别为：
							 void * memcpy(void*dest,constvoid*src,size_tlen);
							 void * memset(void*buffer,intc,size_tnum);
							 这样，任何类型的指针都可以传入memcpy和memset中，这也真实地体现了内存操作函数的意义。
				规则五：void不能代表一个真实的变量
					   解释：下面代码都企图让void代表一个真实的变量，因此都是错误的代码：
							 void a;//错误
							 function(void a);//错误
							 
	8.10 国际C语言混乱代码大赛
	
第9章（再论数组）
199页
	9.1 什么时候数组与指针相同
		1.数组的总结：
					  extern,如extern a[];不能改写成指针的形式
					 /
			    声明 -定义，char[10];不能改写成指针的形式
			         \
			   /      函数的参数,如func(char a[]);可以随自己喜欢，选择数组形式或者指针形式
			  /
		  数组
		      \
			   \
			    在表达式中使用 - 如c=a[i],可以随自己喜欢，选择数组形式或者指针形式
		2.数组和指针在编译器处理时是不同的，运行时也不同，可能会产生不同的代码。对于编译器而言，一个数组代表一个地址，
		  一个指针代表一个地址的地址。
		
	9.2 为什么会发生混淆
		1.人们错误的认为数组和指针互换，是因为遗漏The C Programming Language,第二版中把“char s[]和char* s作为函数的形参时才一样”这句话。
		2.数组和指针作为函数形参可互换的几种用法：
		  例1：
		  	main(int argc,char *argv[]) {};或者main(int argc,char **argv) {};
		  例2：
		  	char my_array[10];
		  	char* my_ptr;
		  	...
		  	i = strlen(my_array);
		  	j = strlen(my_ptr);
		  	printf("%s %s",my_ptr,my_array);
		3.什么时候数组和指针相同：
		  规则1.表达式中的数组名(与声明不同)被编译器指向数组第一个元素的指针。
		  规则2.下标总是与指针的偏移量相同。
		  规则3.在函数参数的声明中，数组名被编译器指向数组第一个元素的指针。
		  9.2.1 规则1.表达式中的数组名就是指针
		  		int a[10],*p,i=2;
		  		可以通过下列任一方式访问a[i];
		  		1）p=a;   p[i];
		  		2）p=a;   *(p+i);
		  		3）p=a+i; *p;
		  9.2.2 规则2.C语言把数组下标作为指针的偏移量
		  9.2.3 规则3.“作为函数参数的数组名”等同于指针
		  		3种函数形参的等同表达：
		  		1）my_function(int* turnip) { ...... };
		  		2）my_function(int turnip[]) { ...... };
		  		3）my_function(int turnip[100]) { ...... };
		  
	9.3 为什么C语言把数组形参当作指针
		1.数组形参时如何引用的：
		  1）对下标形式的数组形参访问所需要的几个步骤：
		  	func(char p[]);		...		c = p[i];
		  	func(char* p);		...		c = p[i];
		  	编译器符号表显示P可以取值从堆栈指针sp便宜14个位置：
		  		运行时步骤1：从SP偏移14个位置找到函数的活动记录，取出实参（假如实参地址=5081）。
		  		运行时步骤2：取i的值，并与5081相加。
		  		运行时步骤3：取出地址(5081+i)的内容。
		  
	9.4 数组片段的下标
	  	1.
	  	
	9.5 数组和指针可交换性的总结
		1.用a[i]的形式对数组进行访问总是被编译器“改写”或解释成*(a+i)这样指针访问。
		2.指针始终时指针，绝对不能改写成数组。你可以用下标形式访问指针，一般都是指针作为函数参数时，而且你知道实际传递给函数的是一个数组。
		3.在特定的上下文钟，也就是它作为函数的参数（也只有这种情况），一个数组的声明可以看作是一个指针，作为函数参数的数组始终会被编译器修改成为指向数组第一个元素的指针。
		4.因此，当把一个数组定义为函数的参数时，可以选择把它定义为数组，也可以定义指针，不管选择哪种方法，在函数内部事实上获得的都是指针，
		5.在其他所有情况钟，定义和声明必须匹配。如果声明了数组，在其他文件钟也要定义数组，指针也是如此，
	  	
	9.6 C语言的多维数组
		9.6.1 把所有其他语言都把这称为“数组的数组”
			1.不同的语言中，”多维数组“的含义各有不同。
			2.在C语言中，可以像下面这样声明一个10*20的多维数组：
				char carrot[10][20];
			  或者声明一个看上去更像“数组的数组”形式：
			  	typedef char vegetable[20];
			  	vegetable carrot[10];		/* 相当于char carrot[10][20] */
			  carror[i][j]数组编译器在编译时会把它解析为*(*(carrot+i)+j)的形式		
		9.6.2 如何分解多维数组
			1.先声明一个多维数组，如下：
				int apricot[2][3][5];
				下列多种方法为他在内存中定位：
				1）int (*p)[3][5] = apricot;		/* sizeof(apricot)=120 */
				2）int (*r)[5] = apricot[i];		/* sizeof(apricot[i])=60 */
				3）int (*t) = apricot[i][j];		/* sizeof(apricot[i][j])=20 */
				4）int u = apricot[i][j][k];		/* sizeof(apricot[i][j][k])=4 */
			2.使用下面声明，编写一个程序，打印r和t的十六进制初始值（使用printf和%x），对两个指针（++），在打印新值：
				int apricot[2][3][5];
				int (*r)[5]=apricot[0];
				int* t=apricot[0][0];
				void main() {
					printf("r'address=%x",r);
					printf("t'address=%x",t);
					r++;
					t++;
					printf("r++'address=%x",r);
					printf("t++'address=%x",t);
				}
				r'address=9b0680
				t'address=9b0680
				r++'address=9b0694
				t++'address=9b0684
		9.6.3 内存中的数组是如何布局的
			1.在多维数组中，最右边的下标最先变化。
			2.多维数组最大的用途是存储多个字符串。
		9.6.4 如何对数组进行初始化
			1.举例：
				short cantaloupe[2][5] = {
				//short cantaloupe[][5] = {
					{10,12,3,4,-5},
					{11,13,13,14,-5},
				}；
				注意：最后一个初始化值后面加了一个逗号，也可以省略它。同时也可以把数组左边下标的长度省略，
					  编译器通过初始化值推断出它的长度。
			2.如果数组的长度比提供的初始化值个数多，剩余的元素自动填充0。
			  如果元素的类型是指针，那么它们被初始化为NULL。
			  如果元素的类型是float，那么它们被初始化为0.0。
			3.下面是初始化二维字符串数组的方法：
				1）二维字符串数组初始化：
					char vegetable[][9] = {
						"beet",
						"barley",
						"basil",
						"broccli",
						"beans"
					};
			    2）一种更有用方法是建立指针数组，因此：
				  	char *vegetable[] = {
						"beet",
						"barley",
						"basil",
						"broccli",
						"crispy fried patatoes"	/* 没问题 */
					};
				注意：指针数组的初始化与字符“数组的数组”初始化部分是一样的。
				      只有字符串常量才可以初始化指针数组。指针数组不能由非字符串类型直接初始化。
				3）指针数组通过非字符串类型初始化的错误示范：
					int *wights[]= {	/* 无法编译成功 */
						{1,2,2};
						{2,3,4,4,4};
						{2,5,2,4}
					};					/* 无法编译成功 */
				4）如果想用这种方式对指针数组初始化，可以创建几个单独的数组，然后用数组名来初始化原来的数组：
					int row_1[] = {1,2,2};
					int row_2[] = {2,3,4,4,4};
					int row_3[] = {2,5,2,4};
					int *wights[]= {	
						row_1,
						row_2,
						row_3
					};
					printf("wights[0][0]=%d \n", wights[0][0]);
					
再论指针
219页
	10.1 多维数组的内存布局
		1.常规情况下我们把二维数组看作排列在一张表格里一行行的一维数组，实际上存储却不是这样，是以线性的方式排列在内存中的。
		2.如何计算左值pea[i][j],先计算p[i]的位置，再根据偏移量[j]取得字符，pea[i][j]被编译器解析为：*(*(pea+i)+j)
	10.2 指针数组就是Iliffe向量		
		1.可以通过声明一个一维指针数组，其中每个指针指向一个字符串来取得二维字符数组的效果。声明如下：
			char* pa[4];与(char*)pa[4];
		2.用来实现多维数组的指针数组有多种名字，如“Iliffe向量”、“display”、“dope向量”。
		  这种形式的指针数组是一种强大的编程技巧，在C语言中得到广泛的运用。
		3.这种数组必须用指向为字符串而分配的内存的指针进行初始化，可以在编译时用常量初始化，也可以运用如下循环的方式分配内存：
		  1）分别用4次循环调用malloc分配整个X*Y个数据的数组内存：
			for(i=0;i<4;i++) {
				pea[i]=(char*)malloc(6);
			}
		  2）a.另一种方法是一次性用malloc分配整个X*Y个数据的数组内存：
		  		char* p;
				p=(char*)malloc(row_size*column_size*sizeof(char));
		     b.然后，使用一个循环，用指针指向这块内存的各个区域：
		     	for(i=0;i<4;i++) {
					pea[i]=p+(i*column_size*sizeof(char));
				}
			 c.整个数组能够保证存储再连续的内存中，即按C分配静态数组的次序。
			 d.一次性用malloc分配的例程：
				void main()
				{
					char* pea[4];		/* 一维指针数组，类似于2维数组 */
					char* p=NULL;
					char row_size=4, column_size=6;
					
					if (p == NULL) {
						p = (char*)malloc(row_size*column_size*sizeof(char));
						memset(p, 0, row_size*column_size*sizeof(char));
					}
					else {
						return;
					}
					printf("p=%p \n", p);
					for (int i = 0; i<row_size; i++) {
						pea[i] = p + (i*column_size*sizeof(char));
						printf("pea[%d]=%p \n", i, pea[i]);
					}
					printf("p=%p \n", p);
					printf("pea=%p \n", pea);
					printf("&pea[0]=%p \n", &pea[0]);
					printf("*pea=%p \n", *pea);

					free(p);
					p = NULL;
					for (int i = 0; i<row_size; i++) {
						pea[i] = NULL;
					}
					printf("p=%p \n", p);
					printf("&pea[0][0]=%p \n", &pea[0][0]);
					printf("&pea[0][5]=%p \n", &pea[0][5]);
					printf("&pea[1][0]=%p \n", &pea[1][0]);
					printf("&pea[1][5]=%p \n", &pea[1][5]);
					printf("&pea[2][0]=%p \n", &pea[2][0]);
					printf("&pea[2][5]=%p \n", &pea[2][5]);
					printf("&pea[3][0]=%p \n", &pea[3][0]);
					printf("&pea[3][5]=%p \n", &pea[3][5]);
				}
				pea[0]=00995278
				pea[1]=0099527E
				pea[2]=00995284
				pea[3]=0099528A
				p=00995278
				pea=003DF998
				&pea[0]=003DF998
				*pea=00995278
				&pea[0][0]=00000000
				&pea[0][0]=00000000
				&pea[0][5]=00000005
				&pea[1][0]=00000000
				&pea[1][5]=00000005
				&pea[2][0]=00000000
				&pea[2][5]=00000005
				&pea[3][0]=00000000
				&pea[3][5]=00000005
			 注意：这种方式减少调用malloc的维护性开销，但缺点是处理完一个字符串时，无法单独将其释放。
		4.当你看见squash[i][j]这样的形式时，你不知道它是怎样被声明的！
		  当你看到squash[i][j]这样的引用形式，你并不知道squash声明为：
				int squash[23][12];			/* int类型的二维数组 */
			或是
				int *squash[23];			/* 23个int类型指针的Iliffe向量 */
			或是
				int **squash;				/* int类型指针的指针 */
			或是
				int (*squash)[12];			/* 类型为int数组（长度为12）的指针 */
		  这有点类似于在函数内部无法分辨传递的实参究竟是一个数组还是一个指针。当然，基于同样的理由：作为左值的数组名被编译器当作是指针。
		5.与数组的数组一样，一个Iliffe向量中的单个字符也是使用两个下标来引用数组中的元素（如pea[i][j]),pea[i][j]被编译器解释为：
			*(*(pea + i) + j)
		  尽管两种下标形式在源代码里一样，而且被编译器解释为同一表达式，但它们在各自的情况下所引用的实际类型并不相同，如下：
		  	1）一个数组的数组：
		  		char a[4][6] ----  一个数组的数组
		  		在编译器符号表中，a的地址为9980
		  		运行时步骤1：取i的值，把它的长度调整为一行的宽度（这里是6），然后加到9980上
		  		运行时步骤2：取j的值，把它的长度调整为一行的宽度（这里是1），然后加到前面所得的结果上
		  		运行时步骤3：从地址（9980+i*scale_factor+j*scale_factor2）取出内容
		  	2）字符串指针的数组
		  		char* p[4] ---- 一个字符串指针数组
		  		在编译器符号表中，p的地址为4624
		  		运行时步骤1：取i的值，乘以指针的宽度（4个字节），然后加到4624上
		  		运行时步骤2：从地址（4624+4*i）取出内容，为“5081”
		  		运行时步骤3：取j的值，乘以元素的宽度（1个字节），然后把结果加到5081上
		  		运行时步骤4：从地址（5081+j*1）取出内容
	10.3 在锯齿状数组上使用指针
		1.Iliffe向量的作用：
			Iliffe向量是一种旧式的编译器编写技巧，最初用于ALGOL60语言。它们原先用于提高数组访问的速度，当时的机器内存优先，通常内存中存储部分数据，这个技巧有助于简化管理任务。在现代的系统中，这两个用途都毫无必要，但Iliffe向量在另外两个方面仍然具有价值：
				1）存储各行长度不一的表
				2）在一个函数调用中传递一个字符串数组
		2.如果需要存储50个字符串，每个字符串最大可存储250个字符，可以声明下面的二维数组：
			char carrot[50][250];
		  它声明了50个字符串，每个字符串保留250字节的空间，即使有些字符串的实际长度只有一两个字节。如果经常这样做，内存的浪费很大。现在有一种替代方法，使用字符串指针数组，它的所有二级数组并不需要保持同一长度。如果声明一个字符串指针数组，根据需要为这些字符串分配内存。大大节省系统资源。有些人把他称作“锯齿状数组”因为它的右端长度不一。
		3.替代方案的字符串指针数组，可以直接指向现有的，也可以通过分配内存创建一份现有字符串的新鲜拷贝。两种创建方法如下：
				char* turnip[UMPTEEN];
				char my_string[]="your message here";
			1）指向现有的字符串:
				turnip[i]=&my_string[0];
			2）创建一份现有字符串的新鲜拷贝:（尽量不用这种方案）
				turnip[j]=(char*)malloc(strlen(my_string)+1);
				strcpy(turnip[j],my_string);
			注意：只要有可能，尽量不要选择拷贝字符串的方案，如果需要从不同的数据结构访问它，拷贝一个指针比拷贝字符串快递多，空间也节省很多。
		4.Iliffe向量的缺点（可能影响性能）：
			Iliffe向量可能会使字符串分配在内存中的不同页面，这就违反了局部引用的规则（一次读写数据位于同一页面上），并导致更加频繁的页面交换，具体如何取决于怎样访问数据以及访问的频度。
		5.数组和指针参数是如何被编译器修改的：
			解释：“数组名被改成一个指针参数”规则并不是递归定义的。数组的数组会被改写为“数组的指针”，而不是“指针的指针”。
			|             实参  			           |             所匹配的形参           |
			|数组的数组    		char c[8][10];         char (*)[10];     数组指针      |
			|指针数组      		char *c[15];           char **c;         指针的指针    |
			|数组指针(行指针)    char (*c)[64];         char (*c)[64];    不改变        |
			|指针的指针    		char **c;        	   char **c;      	 不改变        |
		6.标题9.6.2中显示表达式中的数组名如何变成指针的：上面的表格也显示函数参数的数组名如何变成指针的。这两种情况都受相似的规则支配，就是特定的上下文  环境中，数组名被改写为指针。
		  下面显示了所有有效代码的组合，可以发现：
			  1）3个函数都接受同样类型的参数，就是[2][3][5]int型三维数组或者指向[3][5]int型二维数组的指针
			  2）3个变量：apricot.p,*q都匹配所有3个函数的参数声明
			  3）程序样例：
			  	void my_function_1(int fruit[2][3][5]) {
					printf("function_1'fruit=%p \n", fruit);
				}
				void my_function_2(int fruit[][3][5]) {
					printf("function_2'fruit=%p \n", fruit);
				}
				void my_function_3(int (*fruit)[3][5]) {
					printf("function_3'fruit=%p \n", fruit);
				}
				void main()
				{
					int apricot[2][3][5];
					int(*p)[3][5] = apricot;
					int(*q)[2][3][5] = &apricot;

					my_function_1(apricot);
					my_function_2(apricot);
					my_function_3(apricot);

					my_function_1(p);
					my_function_2(p);
					my_function_3(p);

					my_function_1(*q);
					my_function_2(*q);
					my_function_3(*q);
				}
				function_1'fruit=00FCFAD4
				function_2'fruit=00FCFAD4
				function_3'fruit=00FCFAD4
				function_1'fruit=00FCFAD4
				function_2'fruit=00FCFAD4
				function_3'fruit=00FCFAD4
				function_1'fruit=00FCFAD4
				function_2'fruit=00FCFAD4
				function_3'fruit=00FCFAD4
	10.4 向函数传递一个一维数组
		1.在C语言中，任何一维数组都可以作为函数的实参，形参被改写为指向数组第一个元素的指针，所以需要一个约定来提示数组的长度。一般有两个基本方法：
			1）增加一个额外的参数，表示元素的数目（和argc的作用一样）
			2）赋予最后一个元素为特殊值，提示它是数组的结尾（字符串结尾的‘\0’字符就是起这个作用）。这个特殊值必须不能作为正常的元素值在数组中出现
		2.二维数组的情况要复杂一些，数组被改写为指向数组第一行的指针。现在需要两个约定：
			1）一个是用于提示每行的结束（可用上述一维数组的两种方法）
			2）另一个是用于提示所有行的结束（可用上述一维数组的两种方法）
		3.我们接收的是一个指向数组第一个元素的指针，每次当对指针执行自增操作时，指针就指向数组中下一行的起始位置，但如何知道数组到达最后一行呢？
			1）我们可以增加额外的行，行内所有元素的值都是不可能在数组正常元素中出现的，能够提示数组超出了范围。当对指针进行自增操作时，要对进行检查，看看它是否到达那一行
			2）定义一个额外的参数，提示数组的行数（和argc的作用一样）
	10.5 使用指针想函数传递一个多维数组
		1.如何在函数内部声明一个二维数组形参？
			1）可以使用10.4节的笨拙方法标记数组的范围
			2）由于C编译器需要知道数组的边界，以便为下标引用产生正确的代码。从技术上说，可以在运行的处理才知道数组的边界，而且很多语言也是如此设计，但这种做法违反了C语言的设计理念。所以，C语言没办法表达“这个数组的边界无法在不同调用中可以变化”这个概念
			3）我们能够采取的最好方法是放弃传递二维数组，把array[x][y]这样的形式改写成一维数组array[x+1],它的元素类型是指向array[y]的指针。在数组最后的那个元素array[x+1]里存储一个NULL指针，提示数组结束
		2.C语言中，没有办法向函数传递一个普通的多维数组，传递的问题点如下：
			1）我们需要每一维的长度，以便地址运算提供正确的单位长度
			2）在C语言中，我们没有办法再实参和形参之间交流这种数据（它在每次调用时会改变）。因此，你必须提供除了最左边一维以外的所有维的长度。这样就把实参限制为除最左边一维外所有维都必须与形参匹配的数组。
				invert_in_place(int a[][3][5]);
				用下面两种方法调用都可以：
				int b[10][3][5];  invert_in_place(b);
				int b[99][3][5];  invert_in_place(b);
				但像下面这样任意的三维数组：
				int fails1[10][5][5];  invert_in_place(fails1);	/* 无法通过编译 */
				int fails2[999][3][6]; invert_in_place(fails2);	/* 无法通过编译 */
			注意：二维或更多维的数组无法再C语言中用作一般形式的参数。
		10.5.1 方法1
			通常的方法声明多维数组，迫使函数只能处理10行20列的int型数组，如下：
				my_functiion(int my_array[10][20]);
		10.5.2 方法2
			我们可以合法的省略第一维的长度，像下面这样声明多维数组：
				my_functiion(int my_array[][20]);
			当这样做法仍不够充分，因为每一行都必须正好是20个整数的长度，函数也可以类似的声明：
				my_functiion(int (*my_array)[20]);
			参数列表中(*my_array)周围的括号是绝对需要的，这样可以确保它被翻译为一个指向20个元素的int数组的指针，而不是一个20个int指针元素的数组，同样我们对最右边的一维长度必须为20感到不快。
		10.5.3 方法3
			我们可以采取第三种方法，放弃二维数组，把它结构改为Iliffe向量。也就是，创建一个一维数组，数组中的元素指向其他东西的指针。回想main()函数的两个参数，习惯看到char* argv[]，有时也看到char**argv这种形式，它能提醒我们怎样分析这个声明。可以简单的传递一个指向数组参数的第一个元素的指针，如下所示（用于二维数组）：
				my_functiion(char **my_array);
			注意：只有把二维数组改为一个指向向量的指针数组前提下才可以这样做！
			Iliffe向量这种数据结构的美感在于：它允许认一字符串指针数组传递给函数，但必须是指针数组，而且必须是指向字符串的指针数组。因为字符串和指针都有显式的优越值（分别为NUL和NULL），可以作为结束标记。至于其他类型，并没有一个通用可靠的值，所以并没有一种内置的方法知道何时到达数组某一维的结束位置。即使指向字符串的指针数组，通常也需要一个计数参数argc，记录字符串的数量。
		10.5.4 方法4
			我们可以采取最后一种方法也是放弃多维数组的形式，提供自己的下标方式。错综复杂的迂回方法：
				char_array[row_size * i + j] = ...
			这很误入歧途，让你困惑，如果手工做这些事情，为什么还需要编译器呢？
		总结
			总之，如果多维数组各维的长度都是一个完全相同的固定值，那么它传递一个函数毫无问题。如果情况更普通一点，也更常见一点，就是作为函数的参数数组的长度是任意的，我们用我们用下面的方法进行进一步的分析：
				1）一维数组 --- 没有问题，但需要一个计数值或者能够标识越界位置的结束符。被调用的函数无法检测数组参数的边界。正因为如此，gets()函数存在安全漏洞，从而导致了Iternet蠕虫的产生。
				2）二维数组 --- 不能直接传递给函数，但可以把矩阵改写为一个一维的Iliffe向量，并使用相同的下表方法。对于字符串来说，这样做可以的，对于其他类型，需要增加一个计数值或者能够标识越界位置的结束符。同样它依赖于调用函数和被调用函数之间的约定。
				3）三维或更多维的数组 --- 都无法使用。必须把它分解为几个维度更少的数组。
			对于多维数组作为函数传递的支持缺乏是C语言存在的内在限制。这使得用C语言编写某些特定的类型的程序非常困难（如数值分析算法）。
	10.6 使用指针从函数返回一个数组
		1.前面一节，我们分析了怎样把数组作为参数传递给函数。本节讨论数据的转换：从函数返回一个数组。
		2.严格的说，无法直接从函数返回一个数组。但是可以返回一个指向任何数据结构的指针，当然也可以是指向数组的指针。记住，声明必须在使用之前。
			一个声明和定义的例子：
				int (*paf())[20];		/* paf是一个函数，它返回一个指向包括20个int元素的数组的指针 */
				int (*paf())[20] {
					int (*pear)[20];
					pear=(int (*)[20])calloc(20,sizeof(int));
					if(pear==NULL) longjmp(error,1);
					return pear;
				}
				void main()
				{
					int (*result)[20];	/* 声明一个指向20个int元素的数组的指针 */
					result = paf();
					(*result)[3] = 12;
					printf("result'address=%p \n", result);
					printf("result[0][3]=%d \n", result[0][3]);
					free(result);							/*  free(起始地址的指针) 对内存进行释放 */
					result = NULL;
					printf("result'address=%p \n", result);
				}
				pear'address=01375278
				result'address=01375278
				result[0][3]=12
				result'address=00000000
			或者使用结构体的方式：
				struct a_tag {
					int array[20];
				}x,y;
				struct a_tag my_function() {
					y.array[0] = 10;
					y.array[1] = 13;
					return y;
				}
				void main()
				{
					x = my_function();
					x.array[0] = 12;
					printf("x.array[0]=%d \n", x.array[0]);
					printf("x.array[1]=%d \n", x.array[1]);
					printf("y.array[0]=%d \n", y.array[0]);
					printf("y.array[1]=%d \n", y.array[1]);
				}
				x.array[0]=12
				x.array[1]=13
				y.array[0]=10
				y.array[1]=13
		3.注意：不能从函数返回一个指向函数的局部变量的指针。
	10.7 使用指针创建和使用动态数组
		1.当预先不知道数据的长度时，可以使用动态数组。（绝大多数具有数组的编程语言都能够在运行时设置数组的长度，但是ANSI C不支持）
		2.在ANSI C中，数组是静态的---数组的长度在编译时便已确定不变。在这个领域，C语言支持很弱，甚至不能运用下面的形式：
			const int limit=100;
			char plum[limit];		/* 在C语言中，编译错误error；在C++中，这样的语句合法 */
		3.我们讨论C语言中如何实现动态数组，它的基本思路是使用malloc库函数（内存分配）来得到只想一大块内存的指针，然后，像引用数组一样引用这块内存，其机理就是一个数组下表访问可以改写为一个指针加上偏移量：
			#include	<stdio.h>
			#include	<stdlib.h>
			char *fgets(char *str, int n, FILE *stream);
			int atoi(const char *nptr);
			void main()
			{
				int size;
				char *dynamic;
				char input[10];
				printf("Please enter size of array：");
				size = atoi(fgets(input, 7, stdin));	
				dynamic = (char*)malloc(size);

				dynamic[0] = 'a';
				dynamic[size-1] = 'z';
				printf("size=%d \n", size);
				printf("dynamic[0]=%d \n", dynamic[0]);
				printf("dynamic[size-1]=%d \n", dynamic[size - 1]);
			}
			Please enter size of array：13
			size=13
			dynamic[0]=97
			dynamic[size-1]=122

			解释1：fgets函数，从标准流stdin读取一行（一般指键盘输入到缓冲区里的东西），当读取 (7-1) 个字符或者读取到换行符时，并把它存储在input所指向的字符串内
			解释2：atoi函数是把字符串转换成整型数的一个函数,直到遇上数字或正负符号才开始做转换，而在遇到非数字或字符串结束符('\0')才结束转换，并将结果返回（atoi函数只能转换带数字的字符串）。
		4.我们真正需要实现的是使表具有根据需要自动增长的能力，这样它的唯一限制就是内存的总容量。如果不是直接声明一个数组，而是在运行时堆上分配数组的内存，这样可以实现这个目标。有个库函数realloc()，它能够对现有的内存块重新分配（通常是使它扩大），同时不会丢掉原先内存块的内容。当需要在动态表中增长一个项目时，可以进行如下操作：
			1）对表进行检查，看看它是否真的已满。
			2）如果确实已满，使用realloc()函数扩展表的长度。并进行检查，确保realloc()操作成功进行。
			3）在表中增加所需要的项目。
			用C代码表示，如下：
				int current_element = 0;
				int total_element = 128;
				char *dynamic = (char*)malloc(total_element);
				void add_element(char c) 
				{
					char *dynamic_now;
					if (current_element == (total_element - 1)) {
						total_element *= 2;
						dynamic_now = (char*)realloc(dynamic, total_element);
						if (dynamic_now == NULL) {
							printf("Coundn't expend the table");
							return;
						}
						else {
							dynamic = dynamic_now;
						}
					}
					printf("dynamic=%p \n", dynamic);
					current_element++;
					dynamic[current_element] = c;
				}
				void main()
				{
					for (int i = 0; i < 3 * 128; i++) {
						add_element(i);
						printf("dynamic[%d]=%d \n",i,dynamic[i]);
					}

				}
			注意：在实践中，不要把realloc()函数的返回值直接赋值给字符指针，如果realloc()函数失败，它会使指针的值变为NULL，这样就无法对现有的表进行访问。
		5.realloc()函数技巧在其他许多系统软件中也得到使用，如编译器和调试器。但这个技巧并不是在所有地方都应该使用，理由如下：
			1）当一个大型表格突然需要增长时，系统的运行速度可能会慢下来，而且这在什么时候发生是无法预测的，内存分配成倍增长是最关键的原因。
			2）重分配操作很可能把原先的整个内存块移到一个不同的位置，这个表格中元素的地址便不再有效。为避免麻烦，应该使用下表而不是元素的地址。
			3）所有“增加”和“删除”的操作必须通过函数来进行，这样才能维持表的完整性。只是这样一来，修改表所涉及到的东西就比仅仅操作下表要多得多。
			4）如果表的项目数量减少，可能应该缩小表并释放多余的内存。这样内存收缩的操作对程序的运行速度有很大的影响。每次搜索表格时，编译器最好能够知道任一时刻表的大小。
			5）当某个线程对表进行内存重新分配时，你可能想锁住表，保护表的访问，防止其他线程读取表。对于多线程代码，这种锁总是必要的。
		6.数据结构动态增长的另一种方法是使用链表，但链表不能随机访问。你只能线性的访问链表（除非你把频繁的访问的链表元素的地址保存在缓冲区内），而数组允许随机访问，这可能咋性能上造成很大的差别。
	10.8 轻松一下----程序检验的限制
		1.程序检验是不可行的，反而可能会引起其他错误。

第11章（你懂得C，所以C++不在话下）
	11.1 初识OOP
		1.从实用角度讲，C++是ANSI C的一个超集，它基本上兼容ANSI C。不过C语言的有些特性在C++中并不支持，本章最后有一张表，列出了这些特性。
		2.面向对象编程（OOP）定义：面向对象的关键就是把一些数据和对这些数据进行操作的代码组合在一起，并用某种时髦的手法将它们做成一个单元（许多编程语言把此单元叫做“class（类）”）。
		3.面向对象编程的关键概念：
			1）抽象（abstraction）：它是去除对象中不重要的细节过程，只有那些描述对象的本质特征的关键点才会被保留。抽象是一种设计活动，其他的概念都是提供抽象的OOP概念。
			2）类（class）：类是一种用户定义类型，就好像int这样内置类型一样。内置类型已经有一套完整的针对它的操作（如算术运算等），类机制也必须允许程序员规定他所定义类能够进行操作。类里面的任何东西都被成为类的成员。
			3）对象（object）：某个类的一个特定变量，就像j可能是int类型的一个变量一样，对象也可以被称作类的实例（instance）。
			4）封装（encapsulation）：把类型、数据和函数组合在一起，组成一个类。在C语言中，头文件就是一个非常脆弱的封装实例。因为它的组合形式是纯词法意义上的，编译器并不知道头文件是一个语意单位。
			5）继承（inheritance）：这是一个很大的概念--允许类从一个更简单的基类中接收数据结构和函数。派生类获得基类的数据和操作，并可以根据需要对它们进行改写，也可以在派生类中增加新的数据和函数成员。在C语言中不存在继承的概念，没有任何东西可以模拟这个特性。
		4.现在C++是一个相当庞大的语言。具体来说，一个C编译器的前端大约是40000行代码，而一个C++编译器前端的代码可能是它的两倍，甚至更多。
	11.2 抽象---取实物的本质特征
		1.面向对象编程从面向对象设计开始，而面向对象设计从抽象开始。
		2.抽象：抽象的概念是观察一群“实物”（如汽车、发票或计算机程序），并认识到它们具有一些共同的主题。你可以忽略不重要的区别，只记住能表现事物特征的关键数据项（如许可证号码、预订数量或地址空间边界等）。当你这样做的时候，就是在进行“抽象”。
		3.抽象是非常有用的，因为它允许程序实现下列目标：
			1）隐藏不相关的细节，把注意力集中在本质特征上。
			2）向外部世界提供一个“黑盒子”接口。接口确定了施加在对象之上的有效操作的集合，但它并不提示对象在内部是怎样实现它们的。
			3）把一个复杂的系统分解成几个独立的组成部分。这可以做到分工明确，避免组件之间不符合规则的相互作用。
			4）重用和共享代码。
	11.3 封装---把相关的类型、数据和函数组合在一起
		1.当你把抽象数据类型和操作捆绑在一起的时候，就是在进行“封装”。非OOP语言没有完备的机制来实现封装。我们没有办法告诉C编译器“这3个函数只对这个特定的结构类型才有效”，也没有办法防止程序定义一个新的函数，以未经检查或不一样的方式访问这个结构。
	11.4 展示一些类---用户定义类型享有和预定义类型一样的权限
		1.C++类机制实现了OOP封装的要求，类是封装的软件实现。类也是一种类型，就像char、int、double和stuct rec*都是类型一样。因此，必须定义该类的变量进行有用的工作。类和其他类型一样，可以取得它的大小和声明它的变量等。
		2.对象和变量一样，可以对它进行很多操作，如取得它的地址、把它作为参数传递、作为函数的返回值、使它作为常量值等。一个对象（类的变量）可以像声明其他任何变量一样被声明：
			Vegetable carrot;	/* 这里的Vegetable是类的名字（一般大写开头），而carrot是该类的对象 */

		3.类经常被实现的形式：一个包含多个数据的结构，加上对这些数据进行操作的函数的指针。
		  编译器施行强类型：确保这些函数只会被该类的对象所调用，而且该类的对象无法调用除它们之外的其他函数。
		4.C++的类实现上述的所有目的。它可以看作是一个结构。类通常的形式：
			class 类型 {
				访问控制：声明
				...
				访问控制：声明
			};
	11.5 访问控制
		1.访问控制是一个关键之，它说明了谁可以访问接下来声明的数据和函数。访问控制可以有下面3种之一：
			1）public：属于public的声明在类外面可见，并可进行设置、调用和操纵。一般的原则是不要把类的数据定义成public，因为让数据保持私有是面向对象编程的理论之一，只有类本身才能改变自己的数据，外部函数只能调用类的成员函数。
			2）protected：属于protected声明内容只能由该类本身的函数以及从该类派生的类的函数使用。
			3）private：属于private声明的内容只能被该类成员函数使用。private声明在类外是可见，但不可访问。
		2.另外还有两个关键字也会影响访问控制，它们是friend和virtual。这两个关键字每次只能用于一条声明，而上述关键字每次能跟一大串声明。另外，还有一点不同的是，friend和virtual这两个关键字后不跟冒号!
			1）friend：属于friend的函数不属于类的成员函数，但可以像成员函数一样访问类的protected和private成员，friend可以是一个函数，也可以是一个类。
			2）virtual：到目前为止还没有覆盖这个主题，这个话题搁下，容后再述。
	11.6 声明
		1.C++类的声明就是正常C声明，内容包括函数、类型（包括其他类）或数据，类把它们捆绑在一起，类中每个函数声明都需要一个实现，可以在类里面实现，也可以在类外面实现（这是通常的实现方式），类的总体情况大致如下：
			class Fruit {
				pubilic：
					peel();
					slice();
					juice();
				private：
					int weight,calories_per_oz;
			};
			Fruit melon;
		2.当成员函数在类的外部是实现，前面必须加一些特别的前缀。这个前缀就是::，表示属于这个类，正常的C函数声明：
				返回值 函数名(参数列表)		/* 实现 */
			成员函数的形式则是：
				返回值 类名::函数名(参数列表)	/* 实现 */
		3.前缀::被称为“全局范围分解符”。跟在它前面的标识符就是进行查找的范围，如果::前面没有标识符，就表示查找范围为全局范围。
		4.举例peel()函数在类的内部和外部的实现方式：
			类的内部：
				class Fruit 
				{
					pubilic：
						void peel() {
							printf("in peel")；
						}
						slice();
						juice();
					private：
						int weight,calories_per_oz;
				};
			类的外部：
				class Fruit 
				{
					pubilic：
						peel();
						slice();
						juice();
					private：
						int weight,calories_per_oz;
				};
				void Fruit::peel() 
				{
					printf("in peel");
				}
	11.7 如何调用成员函数
		1.调用成员函数，必须在需要调用的成员函数前面附上类的实例名（或称类的变量，也就是对象）：
			Fruit melon,orange,banana;
			void mian() {
				melon.slice();
				orange.juice();
				return 0;
			}
		2.每个成员函数都有一个this指针，它是隐式赋给该函数的，它允许对象在成员函数内部引用对象本身。注意，在成员函数内部this指针并没有显式出现，这是语言本身设计的。
			class Fruit {
				public:
					void peel();
				private:
					int weight,calories_per_oz;
			};
			void Fruit::peel() {
				printf("this per=%p \n",this);
				this->weight--;
				weight--;			/* this->weight和weight是一个变量，存储地址一样 */
			}
			Fruit apple;
			void main()
			{
				printf("address of apple=%x \n",&apple);
				apple.peel();
			}
			address of apple=9ff320
			this per=009FF320
		3.构造函数和析构函数
			1）绝大多数类至少具有一个构造函数。当类的对象被创建时，构造函数被隐式的调用了，它负责对象的初始化。
			2）类也存在一个清理函数，称为析构函数。当对象被销毁时，析构函数被自动调用。析构函数不如构造函数常用，它里面的代码一般用于处理一些特殊的终止要求以及垃圾收集等。有些人把析构函数当作一种保险方法来确保当对象离开适当的范围时，同步锁总能被释放。所以它们不仅清除对象，还清除对象所持有的锁。
			3）构造函数和析构函数都非常重要，因为类外部的任何函数都不能访问类的private数据成员。因此，需要类内部有一个特权函数来创建一个对象并对其进行初始化。
			4）C++的类中可以声明多个构造函数，由于构造函数的名字和类的名字一样，通过参数来区分它们：
				Classname::Classname(arguments) {...};
				以Fruit为例：
				class Fruit {
					public:
						peel();
						slice();
						juice();
						Fruit(int i,int j);		/* 构造函数 */
						~Fruit();				/* 析构函数 */
					private:
						int weight,calories_per_oz;
				}
				// 构造函数
				Fruit::Fruit(int i,int j) {
					weight=i;
					calories_per_oz=j;
				}
				// 析构函数
				Fruit::~Fruit() {
					printf("over");
				}
				// 对象声明时由构造函数进行初始化
				Fruit melon(4,5),banana(12,8);
			5）构造函数是必要的，因为类通常包含一些结构，而结构又可能包含许多字段。这就需要复杂的初始化。当类的对象被创建时，构造函数会被自动调用，程序员永远不应该显式的调用构造函数。至于全局和静态对象，它们的构造函数会在程序开始时被自动调用，而当程序终止时，它们的析构函数会被自动调用。
			6）构造函数和析构函数违反了C语言中“一切工作自己负责”的原则，它们可以使大量工作在程序运行时隐式的完成，减轻程序员的负担，只不过违背了C语言的哲学。
	11.8 继承---复用已经定义的操作






		
		
		




















参考文献：c专家编程.pdf
