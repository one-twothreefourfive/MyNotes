1.假如判断语句写成if(i=3),编译器不会报错;而写成if(3=i)会报“试图向常数赋值”的错误;
  所以,这里编写判断语句的技巧是：if(3==i),常数在变量前面;
  
2.有符号数和无符号数的比较过程中,有符号数会转变成无符号数,容易造成程序bug
  比如：size_t strlen(char const *string);  // 返回值：无符号整型
		int array[]={ 23,34,12,17,204,99,16 };
		#define TOTAL_ELEMENTS (sizeof(array)/sizeof(array[0]))
		
        bool flag = FALSE;
		// strlen返回无符号数,在比较过程中,-1被转换为无符号(65535),判断语句不成立.
		if(strlen(“123”) > -1) 
		{
			flag = TRUE;
		}
		// TOTAL_ELEMENTS为无符号(sizeof返回无符号数),在比较过程中,-1被转换为无符号(65535),判断语句不成立.
		if(TOTAL_ELEMENTS > -1) 
		{
			flag = TRUE;
		}		
	上例中的TOTAL_ELEMENTS定义为：
		#define TOTAL_ELEMENTS (sizeof(array)/sizeof(array[0]))
	而不是：
		#define TOTAL_ELEMENTS (sizeof(array)/sizeof(int))
	因为前者可以在不修改#define语句的情况下改变数组的基本类型(比如：int修改为char).
	
3.malloc与new分配内存的不同点：
	malloc的函数声明：
		void *malloc(size_t size);// 备注：void* 表示未确定类型的指针,void *可以指向任何类型的
	返回值：
		如果分配成功则返回指向被分配内存的指针(此存储区中的初始值不确定),否则返回空指针NULL.当内存不再使用时,应使用free()函数将内存块释放.
	注意：ANSIC标准规定,该函数返回为void型指针,因此必要时要进行类型转换(强制转换为当前指针类型).
	例如：
		int *p;
		p = (int*)malloc(sizeof(int) * 128);
		//分配128个(可根据实际需要替换该数值)整型存储单元,
		//并将这128个连续的整型存储单元的首地址存储到指针变量p中
	
	NEW:malloc 和 new 至少有两个不同: new 返回指定类型的指针,并且可以自动计算所需要大小.比如：
		int *p;
		int *parr;	
		p = new int;
		//返回类型为int *类型(整数型指针),分配大小为sizeof(int);	
		parr = new int[100];
		//返回类型为int *类型(整数型指针),分配大小为sizeof(int) * 100;
	
	注意：
		第一、malloc 函数返回的是 void * 类型.
			对于C++,如果你写成：p = malloc (sizeof(int)); 则程序无法通过编译,报错：“不能将 void* 赋值给 int * 类型变量”.
			所以必须通过 (int *) 来将强制转换.而对于C,没有这个要求,但为了使C程序更方便的移植到C++中来,建议养成强制转换的习惯.
		第二、函数的实参为 sizeof(int) ,用于指明一个整型数据需要的大小.
			在Linux中可以有这样：malloc(0),这是因为Linux中malloc有一个下限值16Bytes,注意malloc(-1)是禁止的;但是在某些系统中是不允许malloc(0)的.
		在规范的程序中我们有必要按照这样的格式去使用malloc及free:
			1	type *p;
			2	if(NULL == (p = (type*)malloc(sizeof(type))))
			3	/*请使用if来判断,这是有必要的*/
			4	{
			5		perror("error...");
			6		exit(1);
			7	}
			8	.../*其它代码*/
			9	free(p);
			10	p = NULL;/*请加上这句*/
			
4.sizeof和strlen的区别
	char str[20]="0123456789"; 
	int   a=strlen(str); /*a=10;strlen 计算字符串的长度,以\0'为字符串结束标记. 
	int   b=sizeof(str); /*b=20;sizeof 计算的则是分配的数组str[20] 所占的内存空间的大小,不受里面存储的内容影响
    注意：strlen没有计入‘\0’字符,如果要分配空间,需定义为:malloc(strlen(str)+1)
	
5.一个'L'与两个'L'的NULL
	一个'L'的NUL用于结束ACSLL字符串.
	两个'L'的NULL用于什么也指向(空指针).
	
6.一个switch语句允许有257个case语句(满足一个8bit字符的所有情况)

7.
63页
枚举的特点：#define定义的名字一般在编译时被丢掉,而枚举名字一直在调速器中可见,在调试代码时使用它们.
理解C语言声明的优先级规则：
	A 声明从它的名字开始读取,然后按照优先级顺序依次读取.
	B 优先级从高到低依次是：
	  B.1  声明中被括号括起来的那部分
	  B.2  后缀操作符：
	       括号()表示这是一个函数,而方括号[]表示这是一个数组.
	  B.3  前缀操作符：星号*表示“指向...的指针”.
	C 如果const和(或)volatile关键字的后面紧跟类型说明符(如int,long等),那么它作用于类型说明符.在其他情况下,const和(或)volatile关键字作用于它左边紧邻的指针星号.
	C语言声明一例：
	char * const *(*next)();
	解析：next是一个指向函数的指针,该函数返回另一个指针,该指针指向一个只读的指向char的指针.
	char * (*c[10])(int **p);
	解析：c是一个数组【0..9】,它的元素类型是函数指针,该函数形参p一个二级int类型的指针;该函数的返回值指向一个char类型的指针.

一级指针和二级指针：
	一级指针交换变量值,二级指针交换指针地址.

68页
	typedef与#define的区别：
		1.首先,可以用其他类型说明符对宏类型名进行扩展,但对typedef所定义的类型名却不能这样：
      #define peach int
      unsigned peach i; /*没问题,unsigned 扩展为无符号*/
			
      typedef int banana;
      unsigned banana i; /*错误!非法,unsigned 扩展为无符号*/
    2.其次,在连续几个变量的声明中,用typedef定义的类型能保证声明中所有的变量均为同一种类型,而用#define定义的类型则无法保证,如下所示：
      #define int_ptr int*
      int_ptr chalk,cheese; 
	  	/*经过宏扩展,此行变为int * chalk,cheese;chalk为指向int的指针,而cheese则是一个int*/
	  	
	  	typedef char * char_ptr;
	  	char_ptr Bentley,Rolls_Royce;
	  	/*Bentley和Rolls_Royce的类型相同,都是指向char的指针*/
		3.typedef struct fruit{ int weight, price_per_lb; } fruit; 
			声明的两种方式：struct fruit mandarin; 	/* 使用结构标签“fruit” */
											fruit mandarin; 				/* 使用结构类型“fruit” */
		4.结构标签可以取一个“_tag”结尾的名字,使得辨认特定名字变得简单.
		5.strcmp函数比较两个字符串是否相等？当两个字符串相等时,返回值是0.		
      例如：if (!strcmp(s, "volatile")) return QUALIFIER;
        或者#define STRCMP(a,R,b) (strcmp(a,b) R 0)
            if (STRCMP(s, ==,"volatile")) return QUALIFIER;
79页
    理解复杂函数声明:我们可以通过cdecl.c程序,解释这个声明表示什么意思.	

第4章
80页
	区分定义和声明：
		声明:他所说明的并非自身,而是描述其他地方创建的对象.
		定义:它为对象分配内存.
		
	数组与指针不一样：
		extern对象声明告诉编译器对象的类型和名字,对象的内存分配则再别处进行.由于未在声明中为数组分配内存,所以并不需要提供数组的长度信息.
		对于多维数组,需要提供最左边一维之外其他维的长度-这就给编译器足够的信息产生相应的代码.
		
	指针变量：
		char类型指针变量：
		①C/C++语法中输出字符串指针,就是输出字符串,也就是说输出一个char*的指针一定是输出一个字符串,而不会输出指针,其它的类型都不会这样,所以你把它转成void*就会输出地址.
		例子：
		#include<iostream>
		using namespace std;
		
		int main()
		{
			void *pa;
			char a;
			char *p=&a; 
			
			pa = &a;
			cout<<(void*)p<<endl<<a<<endl;
			cout<<pa<<endl;
		}
		实例解析char类型指针与其他类型指针的地址差异分析：
			int main() 
			{ 
				char x[10]= "tanzheng";
				char *x_pter=x;
				int y[8]= { 2,4,6,8,10,12,14,16 };
				int *y_pter=y;
				
				char *str1 = "abcdefdf";
				char *str2 = "abcdefdf";
				char *str3 = "abcdefdfg";
				
				std::cout << "Value of x variable: ";
				std::cout << x << std::endl;
				
				std::cout << "Value of &x[0] variable: ";
				std::cout << &x[0] << std::endl;
	
				std::cout << "Value of (void *)x variable: ";
				std::cout << (void *)x << std::endl;
				
				std::cout << "Value of &x variable: ";
				std::cout << &x << std::endl;
				
				std::cout << "Value of (void *)x[0] variable: ";
				std::cout << (void *)&x[0] << std::endl;
				
				std::cout << "Value of x_pter variable: ";
				std::cout << x_pter << std::endl;
				
				std::cout << "Value of (void *)x_pter variable: ";
				std::cout << (void *)x_pter << std::endl;
				
				std::cout << "Value of &x_pter variable: ";
				std::cout << &x_pter << std::endl;
				
				std::cout << "Value of y variable: ";
				std::cout << y << std::endl;
				
				std::cout << "Value of &y variable: ";
				std::cout << &y << std::endl;
				
				std::cout << "Value of &y[0] variable: ";
				std::cout << &y[0] << std::endl;
				
				std::cout << "Value of y_pter variable: ";
				std::cout << y_pter << std::endl;
				
				std::cout << "Value of &y_pter variable: ";
				std::cout << &y_pter << std::endl;
				
				if ((void *)str1 == (void *)str2)
				{
					std::cout << "(void *)str1 == (void *)str2" << std::endl;
				}
				else
				{
					std::cout << "(void *)str1 != (void *)str2" << std::endl;
				}
				std::cout << "Value of (void *)str1 variable: ";
				std::cout << (void *)str1 << std::endl;
				std::cout << "Value of (void *)str2 variable: ";
				std::cout << (void *)str2 << std::endl;
				std::cout << "Value of (void *)str3 variable: ";
				std::cout << (void *)str3 << std::endl;

				return 0;
			}
			Value of x variable: 							tanzheng
			Value of &x[0] variable: 					tanzheng
			Value of (void *)x variable:			00FEFE0C
			Value of &x variable: 						00FEFE0C
			Value of (void *)&x[0] variable: 	00FEFE0C
			Value of x_pter variable: 				tanzheng
			Value of (void *)x_pter variable: 00FEFE0C
			Value of &x_pter variable: 				00FEFE00
			Value of y variable: 							00FEFDD8
			Value of &y variable: 						00FEFDD8
			Value of &y[0] variable: 					00FEFDD8
			Value of y_pter variable: 				00FEFDD8
			Value of &y_pter variable: 				00FEFDCC
			(void *)str1 == (void *)str2
			Value of (void *)str1 variable: 	0038DC78
			Value of (void *)str2 variable: 	0038DC78
			Value of (void *)str3 variable: 	0038DC84
			
			1.为什么char*指针类型的x取地址时,需强制转换(void *)类型？其他类型的指针变量取地址时不需要强制转换？
				1)char*类型把字符串就是放在文字常量区,定义后不能修改且默认读取字符串数据,强制转换为(void *)类型,才能读取保存在文字常量区首地址.
				2)其他类型的指针(例如short int、long int)可直接取指针变量的地址.
			2.指针变量有几种形态？
				1)y表示指针y对应的内存空间(可以说就是指针本身的值)
   			2)&y表示当前指针对应的内存空间的首地址(存放指针的地址)
   			3)*y表示指针y所指向的变量对应的整个内存空间.(指针指向的空间)
   		3.char*为什么能直接赋值字符串,常规操作时赋予指针地址？比如：char *str=“tanzheng”;
   			1)字符串保存在文字常量区,编译时就确定了,程序运行时实际就是把保存“tanzheng”这个地址,赋值给指针变量str.
   			2)把上述定义的指针变量赋值,比如：*str='A',会报错误.因为*str属于字符常量区,此内存区域只读不能写.
			4.定义连个字符串,比如：char *str1=“tanzheng”;char *str2=“tanzheng”,运行结果为：str1与str2的指针地址相等,为什么？
   			1)相同的字符串在某些编译器中有相同的地址,比较是否为同一字符串时,可以比较地址是否相同.
   				(注意：str1与str2的值不一定相同,这取决于编译器的行为.)
   		5.声明char a[];出现报错？
   			1)声明数组时,如果没有给变量初始化就必须指明数组的长,否则回报错.
   		6.字符数组与字符指针的本质区别？比如：char a[] = "abcde";与char *b = "abcde";
   			1)char 数组的初始化器会将匿名数组(文字常量的字符串)的内容复制到对象所处的空间中,而 char* 的初始化器会将匿名数组(文字常量的字符串)的首地址赋值给对象.
			
第5章
91页
	对衔接的思考
		函数库、链接和载入
			
		警惕Interpositioning
			1.Interpositioning就是通过编写与库函数同名的函数来取代该函数的行为.
			2.同名函数会让程序调用时出错.
			准则;不要让程序中的任何符号成为全局的.除非有意把他们作为程序的接口之一.(通过把函数声明为static函数,使它在所在文件之外不可见或者另外取一个函数名字)
		
		
第6章
115页
	6.1 a.out及其传说
	6.2 段(segments)
		1.一个可执行文件有三个段:文本段(代码段)、数据段、bss段(Block Started by Symbol),可用size的命令查看段的大小.
			text指的是程序指令
			data指的是所有的经过初始化后的全局变量和静态变量
			bss段则是未经初始化的全局变量和静态变量,但是bss段不增加目标文件的大小,一般只是记录bss段的大小.
	6.4 堆栈段
		1.堆栈为函数内部的局部变量提供存储空间.
		2.进行函数调用时,堆栈存储与此有关的一些维护性信息.包括：函数调用地址、人和不适合装入寄存器的参数以及寄存器值得保存.
		3.堆栈也可以被用作暂存区.比如：计算一盒很长的算术表达式时,它可以把部分计算结果压到堆栈中,当需要时再把它从堆栈中取出.例如：alloca()函数分配内存就在堆栈中.
		
	6.8 setjmp和longjmp
		1.setjmp(jmp_buf j)必须首先被调用.表示“使用变量j记录现在的位置.函数返回0”
		2.longjmp(jmp_buf j,int i)可以接着被调用.它表示“回到j所记录的位置,让它看上去像是从原来的setjmp()函数返回一样,但是函数返回i,使代码能够知道它是通过longjmp返回的”
		3.当使用longjmp()时,j的内容被销毁.
		4.goto语句不能跳出C语言当前的函数(这也是“longjmp”取名的由来,它可以跳的很远,甚至可以跳到其他文件的函数之中).
		5.用longjmp只能跳回到曾经到过的地方.在执行setjmp的地方留下有一个过程活动记录.
		例如：
			#include "segjmp.h"
			jmp_buf j;
			#include "segjmp.h"
			
			banana() {
				printf("in banana() \n");
				longjmp(buf,1);
				/*以下代码不会被执行*/
				printf("you'll never see this,because i longjmp");
			}
			main()
			{
				if(setjmp(buf))
					printf("back in main \n");
				else {
					printf("first time through \n");
					banana();
				}
			}
			输出结果：
				first time through
				in banana()
				back in main
		注意：像goto一样,setjmp和longjmp使得程序难以理解和调试,如果不是出于特殊需要,最好避免使用它.
	
	6.11	有用的C语言工具
		1.
		
	6.12 
	
	6.13 汇编嵌入C代码中
		可以在汇编代码前冠以关键字“__asm”,也可以只使用关键字一次,把所有的汇编代码放入花括号内;
		例如：
			__asm {
				mov ah,2;
				mov dl,43h;
				int 21h;
			}
	
第7章(对内存的思考)			
137页
	内存速度的挑战大于内存速度.
	MS-DOC 640K的限制缘何而来：
		1.这个限制源于Inter8086这个最初的DOS机器的最大地址范围.8086支持20位地址,总共时1MB的内存,
		2.F0000到FFFFF          64KB,永久性的ROM区域BIOS、诊断信息等
		  D0000到EFFFF          128KB,用于ROM存储区域
		  C0000到CFFFF          64KB,用于BIOS扩展(XT硬盘)
		  B0000到BFFFF          64KB,用于常规性的内存显示
		  A0000到AFFFF          64KB,用于内存扩展
		  其余
		  00000到9FFFF          640KB,用于应用程序
	PC的内存模型
		MicrosoftC认可下面的内存模型：
			small		所有指针都为16位,代码和数据都限定在一个单一的段中,程序最大规模为128KB(代码段和数据段各64KB)
			large		所有指针都为32位,程序可以包含许多个64KB的段
			medium	代码指针为32位,所以代码段可能有多个.数据指针为16位,所以只有一个64KB的数据段.
		  compact medium的另一种形式：代码指针为16位,所以代码最多不超过64KB.数据指针为32位,所以数据可以占据多个段,但堆栈里的数据仍限制在一个64KB的段内.
		MicrosoftC认可下面非标准的关键字：
			__near  16位指针
			__far   32位指针,但它所指的对象必须全部位于同一个段中(所有的对象均不得超过64KB)
			__huge  32位指针,上述所有的对段的限制都不存在
147页
	7.3 虚拟内存
		虚拟内存的基本思路是用廉价但缓慢的磁盘来扩充快速却昂贵的内存.
		运行下面程序,查询进程能分配多大的内存？
		例如：
			int main()
			{
				#if KB_DEFINE
					int KB=0;
					while(malloc(1 << 10)) ++KB;
					printf("Allocated %d KB totol\n", KB);
				#else
					int MB = 0;
					while (malloc(1 << 20)) ++MB;
					printf("Allocated %d MB totol\n", MB);
				#endif
					return 0;
			}
	7.4 Cache存储器(高速缓存SRAM)
		Cache存储器主要作用是缓解处理数据的两端速度不匹配这种情况带来的时间上的浪费,这样做就加快了访问速度.
		比如：大家都知道的cpu和内存之间的速度差异就特别大,所以需要cache缓存数据,以便提高速度.
		一级缓存：
			都内置在CPU内部并与CPU同速运行,可以有效的提高CPU的运行效率.一级缓存越大,CPU的运行效率越高,但受到CPU内部结构的限制,一级缓存的容量都很小.
		二级缓存：
			它是为了协调一级缓存和内存之间的速度.cpu调用缓存首先是一级缓存,当处理器的速度逐渐提升,会导致一级缓存就供不应求,这样就得提升到二级缓存了.二级缓存它比一级缓存的速度相对来说会慢,但是它比一级缓存的空间容量要大.主要就是做一级缓存和内存之间数据临时交换的地方用. [1] 
		三级缓存：
			是为读取二级缓存后未命中的数据设计的—种缓存,在拥有三级缓存的CPU中,只有约5%的数据需要从内存中调用,这进一步提高了CPU的效率.其运作原理在于使用较快速的储存装置保留一份从慢速储存装置中所读取数据并进行拷贝,当有需要再从较慢的储存体中读写数据时,缓存(cache)能够使得读写的动作先在快速的装置上完成,如此会使系统的响应较为快速. [2] 
		缓存的工作原理：
			是当CPU要读取一个数据时,首先从缓存中查找,如果找到就立即读取并送给CPU处理;如果没有找到,就用相对慢的速度从内存中读取并送给CPU处理,同时把这个数据所在的数据块调入缓存中,可以使得以后对整块数据的读取都从缓存中进行,不必再调用内存.
		保证命中率的算法：
			为了保证CPU访问时有较高的命中率,缓存中的内容应该按一定的算法替换.
			一种较常用的算法是“最近最少使用算法”(LRU算法),它是将最近一段时间内最少被访问过的行淘汰出局.
			因此需要为每行设置一个计数器,LRU算法是把命中行的计数器清零,其他各行计数器加1.
			当需要替换时淘汰行计数器计数值最大的数据行出局.这是一种高效、科学的算法,其计数器清零过程可以把一些频繁调用后再不需要的数据淘汰出缓存,提高缓存的利用率.
		主存和cache如何一一对应？
			主存(DRAM)与Cache(SRAM)的地址都为块号+块内地址,
			CPU如果从主存里面取数据发送的是主存的地址,通过地址里面的块号与cache存储器里面的块号匹配,如果相等命中成功.	
						
	7.5 数据段和堆
		堆
			1.堆区域用于动态分配的存储,通过malloc函数获得的内存.并通过指向访问.
			2.从堆中获取内存的唯一办法就是通过调用malloc(以及同类的calloc、realloc等)库函数.
			  calloc函数与malloc类似,它在返回指针之前,先把分配的内存内容清空为0.
			  realloc函数改变一个指针所指向内存块的的大小,即可以将其扩大,也可以把它缩小.
			3.malloc和free → 从堆中获得内存以及把内存返回给堆.
			  brk和sbrk → 调整数据段的大小至一个绝对值(通过某个增量).
	
	7.6 内存泄漏
		这些C程序在使用malloc()和free()时不得不慎重.堆经常会出现两种类型的问题：
			1.释放和改写仍在使用的内存(称为"内存损坏").
			2.未释放不再使用的内存(称为"内存泄漏")	
		避免内存泄漏
			1.每次当调用malloc分配内存时,注意在以后要调用相应的free来释放它.
			2.也可调用alloca()来分配动态内存,当离开alloca()函数时,分配的内存自动释放,但不适用于函数周期超过创建函数的时间,且移植性不好,建议不用!!
		malloc()函数分配内存的注意事项：
			1.malloc()函数所分配的内存通常会圆整未一个大于申请数量的2的整数次方(如申请212B,会圆整为256B).
		如何检测内存泄漏：
			第一步(检测内存是否泄漏)：
				1.首先,使用swap命令观察还有多少可用的交换空间：
					/usr/sbin/swap -s
					totol：17228Kbyte allocated + 5396k reserved = 22624K uesd,29548K available;
				2.在一两分钟内键入该命令3到4次,看看可用的交换区是否在减少,还可以使用其他一起/use/bin/*stat工具如netstat、vmstat等.
				3.如果发现不断的有内存被分配且从不释放,一个可能的解释就是有个进程出现了内存泄漏.
			第二步(确定可疑进程)
				1.可以使用“pa-lu 用户名”命令来显示所有进程的大小,如下所示：
					F		S		UID		PID		PPID		C		PRI		NI		ADDR		SZ		WCHAN		   TTY		TIME		COMD
					8		S		5303	226		224			80	1			20	FF38F000	199		ff38f1d0   pts/3  0:01		csh
					8		O		5303	921		226			29	1			20	FF38C000	143		           pts/3  0:00		ps
				2.标题SZ的列就是以页面表示的进程大小(如果想知道以KB表示的页面大小,可以用pagesize命令)
				3.同样数次重复这个命令,可以发现任何动态分配内存的进程的大小都在变化.如果一个进程看上去不断地增长而从不缩小,它就有可能出现”内存泄漏“
		运用malloc()函数的理由：
			1.系统经常可以使用不同的malloc函数,有些在运行速度上作了优化.
			2.有些则重视空间的充分利用.
			3.有些对调试有所帮助.
		查询malloc()函数：
			键入命令：man -s 3c malloc,可以游览主文档页面,观察所有malloc系列函数.
		内存泄漏的后果：
			当内核程序请求内存时,他们通常会进行等待,知道有足够的内存可分配;如果出现内存泄漏,最终可能导致无限制等待-于是机器便会挂起.
			
	7.7 总线错误
		常见的运行错误：
			bus error(core dumped)	总线错误(信息已转存)
			和
			segmentation fault(core dumped)	段错误(信息已转存)
			
		7.71 总线错误
			总线错误的原因：
				总线错误几乎都是由于未对齐的读和写引起的.因为出现未对齐的内存访问请求时,被堵塞的组建就是地址总线.
			对齐的含义：
				对齐的含义就是数据项只能存储在地址是数据项大小的整数倍的内存位置上.
				例如：
					访问一个8字节的double数据时,存储地址只允许是8的整数倍.所以数据可以存储于地址：24、8008或32768,但不能存储于1006(因为无法被8整除)
			举例一个总线错误的小程序：
				例如：
					union {
						char a[10];
						int i;
					} u;
					int *p = (int *)&(u.a[1]);
					*p = 17;				/*p中未对齐的地址会引起总线错误!*/
			编译器如何应对内存不对齐的程序？
				1.一个好的编译器能发现不对齐的情况且发出警告,但它并不能检测到所有不对齐的状况.
				2.部分编译器通过自动分配和填充数据来进行对齐;另外一些编译器不会自动对齐,就用一条STR来写入,那必然异常.
				3.指针小转大(u8转u16,u16转u32等)应该被严格禁止的.因为很有可能出现访问不对齐出错.
				4,对齐的数据能提高效率,为了访问未对齐的内存,处理器需要作两次内存访问;而对齐的内存访问仅需要一次访问.
			阐述几种对齐的规则：
				1.数据类型自身的对齐值：对于char型数据,其自身对齐值为1字节,对于short型为2字节,对于
				  int,float,double类型,其自身对齐值为4字节.
				2.结构体的自身对齐值：其成员中自身对齐值最大的那个值.
				3.指定对齐值： #pragma   pack(n)来设定变量以n字节对齐方式.n字节对齐就是说变量存放的起始地址的偏移量有两种情况,
				  第一、如果n大于等于该变量所占用的字节数,那么偏移量必须满足默认的对齐方式,
				  第二、如果n小于该变量的类型所占用的字节数,那么偏移量为n的倍数,不用满足默认的对齐方式.
				4.数据成员和结构体的有效对齐值：数据成员(数据类型)和数据结构的自身对齐值和指定对齐值中小的那个值,数据成员对齐了数据结构自然也就对齐了.

		7.72 段错误
			如果指针引用一个并不位于你的地址空间的地址,操作系统会阻止,引起段错误的程序如下：
			例如：	
				int *p = 0;
				*p = 17;    /* 引起一个段错误 */
				
			SunOS中的一个段违规Bug：
				问题症状：无法运行printf,直接原因是引用一个空指针引起的段违规,问题语句如下：
					(void)printf("%s",p->name);
				解决方案1(新手用啰嗦的修正办法)
					if(p->name != NULL)
					{
						(void)printf("%s",p->name);
					}
					else
					{
						(void)printf("NULL");
					}
				解决方案2(可以用条件操作符,即可简化代码,又可保持引用的局部性)
					(void)printf("%s",p->name ? p->name : "NULL");		/* 输出字符串 */
					
			通常导致段错误的几个直接原因：
				* 解除引用一个包括非法值的指针.
				* 解除引用一个空指针(常常由于从系统程序中返回空指针,并未经检查就使用).
				* 在未得到正确的权限时进行访问.例如：试图往一个只读的文本段写数据导致段错误.
				* 用完了堆栈和堆空间(虚拟内存虽然巨大但绝非无限).
				以发生频率为序,导致段错误的常见编程错误是：
					1.野指针值错误:
						1)在指针赋值之前就用来引用内存,或向库函数传送一个野指针,引起段错误.
						2)对指针进行释放之后再访问它的内容,导致段错误.可以在free函数后,即释放指针后再将它置为NULL.
							例如：free(p);
										p = NULL;
					2.重写(overwrite)错误:
						1)再数组边界外写入数据,再动态分配的内存两端以外写入数据,或改写一些堆管理数据的结构.(在动态分配内存之前的写入数据很容易发生次错误)
							例如：p=malloc(256);
										p[-1]=0;			
										p[256]=0;			/* -1和256都越界了 */
					3.指针释放引起的错误:
						1)释放同一内存块两次及以上
						2)释放一块未曾使用malloc分配的内存(未用malloc函数分配的内存块,就调用free函数释放!)
						3)释放仍在使用中的内存
						4)释放一个无效的指针
					4.在链表中释放元素:
						在遍历链表时正确释放元素的方法是使用临时变量存储下一个元素地址,这样就安全地在任何时候释放当前元素,
						不必担心在取下一个元素地址时还要引用它，代码如下：
							失败的案例：
								struct node *start,*p;
								for(p = start;p;p = p->next)
								{
									free(p);									/* p = p->next语句,程序对已经释放的指针进行解除指针操作 */
								}		
								
							正确的案例：
								struct node *start,*p,*tmp;
								for(p = start;p;p = tmp)
								{
									tmp = p->next;
									free(p);
								}
				
		7.8 轻松一下 ————"Thing King"和"页面游戏"
			规则：
			1.每个进程拥有几百万的“字节”。
			2.字节存放于“页”中，每页4096个字节。位于同一页上的字节具有"本地引用“关系。
			3.页可以存放在内存中，也可以放在磁盘中，内存一般不够大，无法容纳所有的页。
			4.总共只有一块内存，但可以有几个磁盘，所有进程共享内存和磁盘。
			5.每个字节都有自己的虚拟地址。
			6.进程可以对一个字节进行“引用操作”。每个字节轮流进行引用操作。
			7.每个进程只能引用自己的字节，不能引用其进程的字节。
			8.字节只有当他们位于内存中时才能被引用。
			9.只有”虚拟内存管理器“知道某个字节位于内存还是磁盘。
			10.一个字节不被引用的时间越长，它就被称为越”旧“。
			11.进程必须通过“虚拟内存管理器”得到内存。它所给的字节数量是2的倍数或乘方数，这有助于减少开销。
			12.进程引用字节的方法就是给出它的虚拟地址。如果进程给出的虚拟地址恰好位于内存中，那么进程就可以立即引用它、
			   如果它位于磁盘，虚拟内存管理器会把它包含该字节的页移入内存中，如果内存空间已满，它就寻找内存中最旧的页
			   （可能是该进程自己的，也可能是其他进程的），把它换到磁盘中，腾出的空间就存放包含你需要字节的页。然后进程
			   就可以引用该字节，当进程并不知道该页原先位于磁盘中。
			13.每个进程拥有的字节的虚拟地址与其他进程一样，虚拟内存管理器始终知道谁拥有哪个字节以及该轮到谁进行引用操作，
			   所以一个进程不会无意引用其他进程的字节，即使两者的虚拟地址相同。
			
			说明
			1.根据传统，虚拟内存使用一张很大且分段的表，另外还有页表记住所有字节的位置以及它们的主人。
			2.规则13的结果就是各自运行中每个进程的虚拟地址都类似，即使进程的数量有变化。
			3.虚拟内存管理器也拥有自己的一些字节，它们中的有些也和进程的字节一样在内存和磁盘中移来移去，但是，
			  它的有些字节使用频率非常之高，所以常驻内存。
			4.按照上述规则，经常引用的字节更有可能被存放在内存中，而不太被引用的字节更有可能存放在磁盘中，这可以提高内存的使用效率。
			
			解决方案：
			捕捉段错误信号和信号处理程序
			例如：
				#include <signal.h>
				#include <stdio.h>
				
				void handler(int s)
				{
					if(s == SIGBUS) printf(" now got a bus error signal\n");
					if(s == SIGSEGV) printf(" now got a segmentation violation signal\n");
					if(s == SIGILL) printf(" now got a illegal instrution signal\n");
					exit(1);
				}
				void main()
				{
					int *p = NULL;
					signal(SIGBUS,handler);
					signal(SIGSEGV,handler);
					signal(SIGILL,handler);
					*p = 0;						/* 非法内存访问，会产生SIGSEGV信号，打印对应的提示信息 */
				}
				运行改程序，输出结果如下：
				% a.out
					now got a segmentation violation signalow 
			
第8章（为什么程序员无法分清万圣节和圣诞节）
169页
	8.2 根据位模式构筑图形
		图标或图形，是一种小型的位模式映射于屏幕产生的图像。一个位代表图形的一个像素。
		C语言中，典型的16*16的黑白图形可能如下：
			static unsigned short stopwatch[] = {
				0x07C6,
				0x1FF7,
				0x383B,
				0x500C,
				0x500C,
				0xC006,
				0xC006,
				0xDF06,
				0xC106,
				0xC106,
				0x510C,
				0x510C,
				0x3838,
				0x1FF0,
				0x07C0,
				0x0000
			};
			上面的C语言常量并未提供有关图形实际模样的任何线索。这里有一个惊人的#define定义的优雅集合，
			允许程序建立常量使它们看上去像是屏幕上的图形。
			#define X )*2+1
			#define _ )*2
			#define s ((((((((((((((((0			/* 用于创建16位宽的图形 */
			/* 使用上面的宏定义，程序就可以描述出对应的图形，程序的自描述能力大大加强 */
			static unsigned short stopwatch[] = 
			{
				s _ _ _ _ _ X X X X X _ _ _ X X _,
				s _ _ _ _ _ X X X X X _ _ _ X X _,
				s _ _ X X X _ _ _ _ _ X X X _ X X,
				s _ X X _ _ _ _ _ _ _ _ _ X X _ _,
				s _ X X _ _ _ _ _ _ _ _ _ X X _ _,
				s X X _ _ _ _ _ _ _ _ _ _ _ X X _,
				s X X _ _ _ _ _ _ _ _ _ _ _ X X _,
				s X X _ X X X X X _ _ _ _ _ X X _,
				s X X _ _ _ _ _ X _ _ _ _ _ X X _,
				s X X _ _ _ _ _ X _ _ _ _ _ X X _,
				s _ X X _ _ _ _ X _ _ _ _ X X _ _,
				s _ X X _ _ _ _ X _ _ _ _ X X _ _,
				s _ _ X X X _ _ _ _ _ X X X _ _ _,
				s _ _ _ X X X X X X X X X _ _ _ _,
				s _ _ _ _ _ X X X X X _ _ _ _ _ _,
				s _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
			};
			注意：千万不要忘记在绘图结束后清除这些宏定义，否则可能会给你后面的代码带来不可预测的后果。
					#ifdef X
						#undef X
					#endif
					/*------*/
					#ifdef _
						#undef _
					#endif
					/*------*/
					#ifdef s
						#undef s
					#endif
					/*------*/
					
		C语言实例：
			#include	<stdio.h>
			
			#define X )*2+1
			#define _ )*2
			#define s ((((((((((((((((0			/* 用于创建16位宽的图形 */
			/* 使用上面的宏定义，程序就可以描述出对应的图形，程序的自描述能力大大加强 */
			static unsigned short stopwatch[] =
			{
			#if 1
				s _ _ _ _ _ X X X X X _ _ _ X X _,
				s _ _ _ _ _ X X X X X _ _ _ X X _,
				s _ _ X X X _ _ _ _ _ X X X _ X X,
				s _ X X _ _ _ _ _ _ _ _ _ X X _ _,
				s _ X X _ _ _ _ _ _ _ _ _ X X _ _,
				s X X _ _ _ _ _ _ _ _ _ _ _ X X _,
				s X X _ _ _ _ _ _ _ _ _ _ _ X X _,
				s X X _ X X X X X _ _ _ _ _ X X _,
				s X X _ _ _ _ _ X _ _ _ _ _ X X _,
				s X X _ _ _ _ _ X _ _ _ _ _ X X _,
				s _ X X _ _ _ _ X _ _ _ _ X X _ _,
				s _ X X _ _ _ _ X _ _ _ _ X X _ _,
				s _ _ X X X _ _ _ _ _ X X X _ _ _,
				s _ _ _ X X X X X X X X X _ _ _ _,
				s _ _ _ _ _ X X X X X _ _ _ _ _ _,
				s _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
			#else
				s _ _ _ _ _ X X X X X _ _ _ X X _,
				s _ _ _ _ _ X X X X X _ _ _ X X _,
				s _ _ X X X _ _ X _ _ X X X _ X X,
				s _ X X _ _ _ _ X _ _ _ _ X X _ _,
				s _ X X _ _ _ _ X _ _ _ _ X X _ _,
				s X X _ _ _ _ _ X _ _ _ _ _ X X _,
				s X X _ _ _ _ _ X _ _ _ _ _ X X _,
				s X X X X X X X X X X X X X X X _,
				s X X _ _ _ _ _ X _ _ _ _ _ X X _,
				s X X _ _ _ _ _ X _ _ _ _ _ X X _,
				s _ X X _ _ _ _ X _ _ _ _ X X _ _,
				s _ X X _ _ _ _ X _ _ _ _ X X _ _,
				s _ _ X X X _ _ _ _ _ X X X _ _ _,
				s _ _ _ X X X X X X X X X _ _ _ _,
				s _ _ _ _ _ X X X X X _ _ _ _ _ _,
				s _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
			#endif
			};
			
			#define ushort_bit_length 16
			void main()
			{
				int buf_length;
				buf_length = sizeof(stopwatch)/2;
				printf("buf_length = %d\n", buf_length);
				printf("\n");
			
				for (int i = 0; i < buf_length; i++)
				{
					for (int j = 0; j < ushort_bit_length; j++)
					{
						if (j == 0)
						{
							printf("s");
						}
						else
						{
							if ((stopwatch[i] << j) & 0x8000)
							{
								printf("X");
							}
							else
							{
								printf("_");
							}
						}
					}
					printf("\n");
				}
				printf("\n");
			
				#ifdef X
					#undef X
				#endif
			
				#ifdef _
					#undef _
				#endif
			
				#ifdef s
					#undef s
				#endif
			
				#ifdef X
					printf("#ifdef X able\n");
				#else
					printf("#undef X able\n");
				#endif
			
				#ifdef _
					printf("#ifdef _ able\n");
				#else
					printf("#undef _ able\n");
				#endif
			
				#ifdef s
					printf("#ifdef s able\n");
				#else
					printf("#undef s able\n");
				#endif
			}

	8.4 原型之痛
		
	8.5 原型在什么地方会失败
		不要再函数的声明和定义中混用新旧两种风格
			1.坚决不要再函数声明和定义中混用新旧两种风格。如果函数在头文件中的声明是K&R
				C风格的，那么函数的定义也应该使用K&R C风格的语法。
				例：int foo();	
						int foo(a,b) 
						int a;
						int b;
						{
							;
						}
			2.如果函数具有ANSI C原型,那么在它的定义中也使用ANSI C风格语法。
				例：int foo(int a,int b);	
						int foo(int a,int b) 
						{
							;
						}
		
	8.6 不需要按回车键就能得到一个字符
		Micorsoft和Borland的C编译器提供了getch()（或getche()，它可以使字符在读取的同时回显于屏幕上）来获取单个字符，而不用等待整行结束。
		Windows 系统下的 vs 中可以使用 _kbhit() 函数来获取键盘事件，使用时需要加入 conio.h 头文件。
		
		C/C++ 获取键盘事件
			1.Windows 系统下的 vs中的用法：
				#include <conio.h>
				#include <iostream>
				 
				using namespace std;
				 
				int main()
				{
					int ch;
					while (1){
						if (_kbhit()){//如果有按键按下，则_kbhit()函数返回真
							ch = _getch();//使用_getch()函数获取按下的键值
							cout << ch;
							if (ch == 27){ break; }//当按下ESC时循环，ESC键的键值时27.
						}
					}
					system("pause");
				}
			2.在 Unix/Linux 下，并没有提供 kbhit() 函数。我们可以自己来实现 kbhit() 程序。
			  在UNIX中，有两种方法实现逐字符的输入，一种很难，一种很容易。
				1）.容易的方法让stty程序来实现这个功能：（通过终端命令的方式间接实现）
					#include <stdio.h>
					main()
					{	
						int c;
						system("stty raw");			/* 终端驱动处于一次一个字符模式 */
						c = getchar();
						system("stty cooked");		/* 终端驱动处又回到一次一行模式 */
						
					}
					总结：
						a.最后一行不能省略system("stty cooked");因为程序结束后，终端字符驱动特性还会延续下去。
						  这和设置环境变量明显不同，后者在进程结束后自动消失。
						b.此方法把I/O设置为raw状态实现阻塞式读入，如果终端没有字符输入，进程就一直等待，直到字符输入为止。
				2）.此方案可实现非阻塞式读入，使用ioctl()（I/O控制）系统调用。此函数可判断是否有按键按下,通过轮询判断按键按下，才进行字符读入：
					//#include <sys/filio.h>	/* 此头文件在Linux下Ubuntu系统编译出错，可能只能用于Unix系统，用<sys/ioctl.h>替代 */		
					#include <sys/ioctl.h>		/* BSD and Linux，ioctl()函数的头文件 */
					#include <errno.h>			/* errno变量的头文件 */
					#include <stdio.h>
					
					int kbhit()
					{
						int i;
						
						errno=0;				/* 如果库函数调用或系统调用遇到问题时，errno变量被设置以提示问题原因 */	
						if(ioctl(0,FIONREAD,&i) < 0) {
							if(errno == EBADF) printf("errno: bad file number");
							if(errno == EINVAL) printf("errno: invalid argument");
						}
						return i;
					}
					main()
					{	
						int i = 0;
						char c=' ';
						
						system("stty raw -echo");		/* 终端驱动处于一次一个字符模式且关闭回显 */
						printf("input 'q' quit \n");	/* printf()函数内如果不加"\n"，可能导致终端设备不显示此内容 */
						for(;c!='q';i++) {
							if(kbhit()) {
								c = getchar();
								printf("\n got %c,on iteration = %d",c,i);
							}
						}
						system("stty cooked echo");		/* 终端驱动处又回到一次一行模式且打开回显 */
					}
				
		Linux/Unix下广泛应用的图形函数库curses,取代stty命令，改写上面的main函数代码：
			#include <curses.h>			/* 使用curses函数库和前面定义的kbhit()函数 */
			#include <errno.h>
			#include <sys/ioctl.h>
			
			int kbhit()
			{
				int i;
			
				errno=0;
				if(ioctl(0,FIONREAD,&i) < 0) {
					if(errno == EBADF) printf("errno:bad file number");
					if(errno == EINVAL) printf("errno: invalid argument");
				}
				return i;
			}
			main()
			{
				char c=' ';
				int i = 0;
				
				initscr();				/* 初始化curses函数 */
				cbreak();
				noecho();				/* 按键时不在屏幕回显字符 */
				mvprintw(0,0,"Press 'q' quit \n");
				refresh();
				
				while(c != 'q') {
					if(kbhit()) {
						c = getchar();	/* 不会阻塞，因为我们知道有个字符正在等待 */
						mvprintw(1,0,"got %c,on iteration %d \n",c,++i);
						refresh();
					}
				}
				nocbreak();
				echo();
				endwin();				/* 结束curses进程 */
			}
			总结：
				a.可以直接在usr/include下查看是否有该头文件<curses.h>，如果没有需安装curses库（>sudo apt-get install ncurses-dev ），
				  curses函数库的头文件和库文件就被分别安装在/usr/include/和/usr/lib/下。
				b.在编译程序时，直接使用命令：gcc program.c -o program -lcurses，完成编译，运行。
			
	8.7 用C语言实现有限状态机
		1.有限状态机（Finite-state machine）是一个非常有用的模型，可以模拟世界上大部分事物，它有三个特征：
		　　* 状态总数（state）是有限的。
		　　* 任一时刻，只处在一种状态之中。
		　　* 某种条件下，会从一种状态转变（transition）到另一种状态。
		2.基本思路是一张表保存所有可能的状态，并列出每个状态可能执行的所有动作，其中最后一个动作就是
		  计算（通常当前状态和下一次输入字符的基础上，另外在经过一次表查询）下一个应该进入的状态。
		3.在C语言中，有好几种方法可以表达FSM，但绝大多数都是基于函数指针数组,具体如下：
		  a.一个函数指针数组可以如下声明：
		  	void (*state[MAX_STATES])();
		  b.如果知道了数组名，可以用下面方式进行初始化：
		  	extern int a(),b(),c(),d();
		  	int (*state[])() ={ a,b,c,d };
		  c.可以通过数组指针来调用函数：
		    (*state[i])();
		  注意：所有函数必须接收同样的参数，并返回同样类型的返回值（除非把数组元素做一个联合），
		4.如果想设计的更漂亮，可以让状态函数返回一个指向通用后续函数的指针，并把它转换为适当的类型。
		  这样就不需要全局变量。如果不想太花哨，可以使用switch语句作为简朴的状态机。
		5.关于FSM还有最后一点说明：如果你的状态函数需要多个不同的参数，可以考虑使用参数计数器和一个字符串指针数组，
		  就像main函数的参数一样，我们熟悉的int argc；char *argv[]机制非常普遍，可以成功的运用在你所定义的函数中。
		
	8.8 软件比硬件困难
		1.FMS编写代码时使用两个明显的阶段：
		  a.首先进行状态切换，只有当他们处于工作状态时才提供动作。
		  b.可调式性代码的方式构建框架：把系统分成几个部分，先让程序总体运行。只有基本的程序运行后，你才为那些复杂的细节完善、性能调整和算法优化进行编码。
		2.运用可调式编码方式实现“散列函数”：
		  a.先完成最简单能运行的程序，就是散列函数总是返回0：
		  	/* hash_file:占位符s为将来更复杂的程序预留位置 */
		  	int hash_filename(char *s) {
		  		return 0;
		  	}
		    调用这个散列函数的程序如下：
		    /**
		     * find_file:定位以前建立的文件描述符，需要时可以新建一个
		     */
		    file find_filename(char *s)
		    {
		    	int hash_value = hash_filename(s);
		    	file f;
		    	for(f = file_hash_table[hash_value];f != NIL;f = f -> flink) {
		    		if(strcmp(f->fname,s) == SAME) {
		    			return f;
		    		}
		    	}
		    	
		    	f = allocate_file(s);
		    	f->flink = file_hash_table[hash_value];
		    	file_hash_table[hash_value] = f;
		    	return f;
		    }
		    上述效果像是一个散列表还未被使用，所有元素存储在第0个元素后面的链表之中。使得函数很容易实现和调试，因为无需实现散列函数的具体值，
		    下面实现hash_filename()函数：
		    int hash_filename(char *s) {
		    	int length = strlen(s);
		    	return (length+4*(s[0]+4*s[length/2])) / FILE_HASH;
		    }
		3.编程挑战：（把上述编程片段补充完整，实现散列函数）
			#include <stdio.h>
			#include <stdlib.h>
			#include <string.h>
			
			#define TABLE_SIZE (16)		// TABLE_SIZE赋值为16或者2的幂次；否则，不能通过data & (TABLE_SIZE-1)计算索引值（data % TABLE_SIZE的方式计算索引值）
            
            /* handlersh表和基本数据节点 */
            typedef struct _node {
				int data;
				struct _node* next;
			} NODE;
			
			typedef struct _hash_table {
				NODE* value[TABLE_SIZE];
			} HASH_TABLE;
			
			typedef enum {
				FALSE = 0,
				TRUE
			}STATUS;
			
            /* 创建hash表 */
			HASH_TABLE* create_hash_table()
			{
				HASH_TABLE* pHashTb1 = (HASH_TABLE*)malloc(sizeof(HASH_TABLE));
				memset(pHashTb1, 0, sizeof(HASH_TABLE));
				return pHashTb1;
			}
            
            /* 在hash表当中寻找数据 */
			NODE* find_data_in_hash(HASH_TABLE* pHashTbl, int data)
			{
				int i=0;
				NODE* pNode;
				if (NULL == pHashTbl)
					return NULL;
			
				//if (NULL == (pNode = pHashTbl->value[data % TABLE_SIZE]))
				if (NULL == (pNode = pHashTbl->value[data & (TABLE_SIZE - 1)]))
					return NULL;
			
				while (pNode){
					if (data == pNode->data)
						return pNode;
					pNode = pNode->next;
					i++;
				}
				return NULL;
			}
            
            /* 在hash表当中插入数据 */
			STATUS insert_data_into_hash(HASH_TABLE* pHashTbl, int data)
			{
				NODE* pNode;
				if (NULL == pHashTbl)
					return FALSE;
			
				//if (NULL == pHashTbl->value[data % TABLE_SIZE]){
				if (NULL == pHashTbl->value[data & (TABLE_SIZE - 1)]){
					pNode = (NODE*)malloc(sizeof(NODE));
					memset(pNode, 0, sizeof(NODE));
					pNode->data = data;
					//pHashTbl->value[data % TABLE_SIZE] = pNode;
					pHashTbl->value[data & (TABLE_SIZE - 1)] = pNode;
					return TRUE;
				}
			
				if (NULL != find_data_in_hash(pHashTbl, data))
					return FALSE;
			
				//pNode = pHashTbl->value[data % TABLE_SIZE];
				pNode = pHashTbl->value[data & (TABLE_SIZE - 1)];
				while (NULL != pNode->next)
					pNode = pNode->next;
			
				pNode->next = (NODE*)malloc(sizeof(NODE));
				memset(pNode->next, 0, sizeof(NODE));
				pNode->next->data = data;
				return TRUE;
			}
            
            /* 从hash表中删除数据 */
			STATUS delete_data_from_hash(HASH_TABLE* pHashTbl, unsigned long int data)
			{
				NODE* pHead;
				NODE* pNode;
				//if (NULL == pHashTbl || NULL == pHashTbl->value[data % TABLE_SIZE])
				if (NULL == pHashTbl || NULL == pHashTbl->value[data & (TABLE_SIZE - 1)])
					return FALSE;
			
				if (NULL == (pNode = find_data_in_hash(pHashTbl, data)))
					return FALSE;
			
				//if (pNode == pHashTbl->value[data % TABLE_SIZE]){
				if (pNode == pHashTbl->value[data & (TABLE_SIZE - 1)]){
					//pHashTbl->value[data % TABLE_SIZE] = pNode->next;
					pHashTbl->value[data & (TABLE_SIZE - 1)] = pNode->next;
					goto final;
				}
			
				//pHead = pHashTbl->value[data % TABLE_SIZE];
				pHead = pHashTbl->value[data & (TABLE_SIZE - 1)];
				while (pNode != pHead->next)
					pHead = pHead->next;
				pHead->next = pNode->next;
			
				final:
				free(pNode);
				return TRUE;
			}
			
			/* the classic Times33 hash function */
			static int hash_33(char* key)
			{
				int hash = 0;
				while (*key) {
					hash = (hash << 5) + hash + *key++;
					//hash = hash * 33 + *key++;
				}
				return hash;
			}
			
			void main()
			{
				NODE* p_node = NULL;
				HASH_TABLE* p_hash_table = NULL; 
				STATUS e_status;
				int hash_code;
				char input[] = "book";
				char input2[] = "tanzheng";
			
				p_hash_table = create_hash_table();
				if (p_hash_table != NULL) {	
					printf("create hash_table ok,address=%p \n", p_hash_table);
					hash_code = hash_33(input);
					e_status = insert_data_into_hash(p_hash_table, hash_code);
					e_status = insert_data_into_hash(p_hash_table, hash_code);
					e_status = insert_data_into_hash(p_hash_table, 16139);
					e_status = insert_data_into_hash(p_hash_table, 7723);
					e_status = insert_data_into_hash(p_hash_table, 7724);
					e_status = insert_data_into_hash(p_hash_table, 7725);
                    e_status = delete_data_from_hash(p_hash_table, 16139);
                    e_status = delete_data_from_hash(p_hash_table, 7724);
					if (e_status == TRUE) {
						printf("SUCCESS \n");
					}
					else {
						printf("FAILURE \n");
					}
				}
			}
			注意：1.TABLE_SIZE赋值为16或者2的幂次；否则，不能通过data & (TABLE_SIZE-1)计算索引值（data % TABLE_SIZE的方式计算索引值）。
				  2.Hash算法最终得到的index结果，完全取决于Key的Hashcode值的最后几位。（上述的Hashcode算法用的hash_33()函数）。
				  3.Hash碰撞时，运用链表保存对应的索引结构下,称为"链式扩展"。
                  4.
		 4.补充知识（strlen与sizeof的区别？）
			a.sizeof
				sizeof(...)是运算符，在头文件中typedef为unsigned int，其值在编译时即计算好了，参数可以是数组、指针、类型、对象、函数等。
				它的功能是：获得保证能容纳实现所建立的最大对象的字节大小。
				由于在编译时计算，因此sizeof不能用来返回动态分配的内存空间的大小。实际上，用sizeof来返回类型以及静态分配的对象、结构或数组所占的空间，返回值跟对象、结构、数组所存储的内容没有关系。
				具体而言，当参数分别如下时，sizeof返回的值表示的含义如下：
				数组——编译时分配的数组空间大小；
				指针——存储该指针所用的空间大小（存储该指针的地址的长度，是长整型，应该为4）；
				类型——该类型所占的空间大小；
				对象——对象的实际占用空间大小；
				函数——函数的返回类型所占的空间大小。函数的返回类型不能是void。
				**************
			b.strlen
			    strlen(...)是函数，要在运行时才能计算。参数必须是字符型指针（char*）。当数组名作为参数传入时，实际上数组就退化成指针了。
			    它的功能是：返回字符串的长度。该字符串可能是自己定义的，也可能是内存中随机的，该函数实际完成的功能是从代表该字符串的第一个地址开始遍历，直到遇到结束符NULL。返回的长度大小不包括NULL。
			c.举例：
			    eg1.char arr[10] = "What?";
		            int len_one = strlen(arr);
		            int len_two = sizeof(arr); 
		            cout << len_one << " and " << len_two << endl; 
			    	输出结果为：5 and 10
			    	点评：sizeof返回定义arr数组时，编译器为其分配的数组空间大小，不关心里面存了多少数据。strlen只关心存储的数据内容，不关心空间的大小和类型。
			    eg2.char * parr = new char[10];
			        int len_one = strlen(parr);
			        int len_two = sizeof(parr);
			        int len_three = sizeof(*parr);
			        cout << len_one << " and " << len_two << " and " << len_three << endl;
			        输出结果：23 and 4 and 1
			        点评：第一个输出结果23实际上每次运行可能不一样，这取决于parr里面存了什么（从parr[0]开始知道遇到第一个NULL结束）；第二个结果实际上本意是想计算parr所指向的动态内存空间的大小，但是事与愿违，sizeof认为parr是个字符指针，因此返回的是该指针所占的空间（指针的存储用的是长整型，所以为4）;第三个结果，由于*parr所代表的是parr所指的地址空间存放的字符，所以长度为1。
			        ************





































参考文献：c专家编程.pdf
